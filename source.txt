:: StoryTitle
Story Title


:: StoryData
{
	"ifid": "5406BF44-CF93-41CF-9DED-9824A52E2F82",
	"format": "SugarCube",
	"format-version": "2.30.0",
	"start": "Start",
	"zoom": 1
}


:: Story Stylesheet [stylesheet]
html {
    font: 100% Georgia, serif;
}
body {
    color: white;
    background-color: black;
}
a {
    cursor: pointer;
    color: #68d;
    text-decoration: none;
    font-weight: bold;
    transition-duration: 200ms;
}
.description {
  color: yellow;
}


:: Story JavaScript [script]
/* twine-user-script #1: "0010-standard.js" */
/*
Establishes shorthand aliases for the following namespaces in
SugarCube: `setup`, `settings`, `State.variables`, and
`State.temporary`.

All classes and functions are built on the `s` namespace. All instances
are built on the `v` namespace.
*/

Object.defineProperty(window, "s", {
    get: function() {
        return setup;
    }
});

Object.defineProperty(window, "ss", {
    get: function() {
        return settings;
    }
});

Object.defineProperty(window, "v", {
    get: function() {
        return State.variables;
    }
});

Object.defineProperty(window, "t", {
    get: function() {
        return State.temporary;
    }
});
/* twine-user-script #2: "0020-List.js" */
s.List = function() {
    /*
    A wrapper around an array with methods for controlling manipulation
    and access of elements.
    */
    this._array = [];
    return this;
}

s.List.prototype._verify = function(obj) {
    /*
    Checks if `obj` qualifies to be in the list. Should be overwritten
    by subclasses.
    */
    return true;
}

s.List.prototype.push = function() {
    /*
    Takes any number of objects as parameters. If any given object
    fails the `_verify` test, throws an error. Otherwise, adds all
    objects to `_array` and returns the calling `List` object.
    */
    if (arguments.length > 0) {
        var args = Array.prototype.slice.call(arguments);
        var arg = args.shift();
        if (this._verify(arg)) {
            this._array.push(arg);
        } else {
            throw new Error(
                'List.push():\n' +
                'object does not qualify for list'
            );
        }
        this.push.apply(this, args);
    }
    return this;
}

s.List.prototype.delete = function(index) {
    /*
    Deletes the list element at the given index and returns the modified
    `List` object. Throws an error if index is out of range. Returns the
    calling `List` object.
    */
    if (index !== parseInt(index, 10) || index < 0 ||
        index >= this._array.length) {
        throw new Error(
            'List.delete():\n' +
            'invalid index'
        );
    }
    this._array.splice(index, 1);
    return this;
}

s.List.prototype.get = function(index) {
    return this._array[index];
}

s.List.prototype.indexOf = function(obj) {
    return this._array.indexOf(obj);
}

s.List.prototype.length = function() {
    return this._array.length;
}
/* twine-user-script #3: "0030-Outcome.js" */
s.Outcome = function(func) {
    /*
    Represents one possible result of a player action.

    @param {Function} func - The function to call when the outcome is
    carried out.
    */
    this._userScript = func;
    return this;
}

s.Outcome.prototype.carryOut = function() {
    return this._userScript();
}
/* twine-user-script #4: "0040-Action.js" */
s.Action = function(text, checkFunc, chooseFunc) {
    /*
    In a given passage, the reader will choose from a list of actions.
    Each action can be displayed as a link, and when it is selected,
    the story will choose from a list of that action's possible
    outcomes. An `Action` object represents one of these actions.

    Structurally, an action object is a list of outcomes with a display
    text for the link, and some additional methods available. As such,
    it is implemented as a subclass of `List`.

    @param {String} text - The text to appear in the link.
    @param {Function|Boolean} checkFunc (optional) - The function to
    call when checking if the action should be displayed. Should return
    a boolean. If a boolean is provided, simply returns that boolean.
    Defaults to true.
    @param {Function} chooseFunc (optional) - The function to call when
    choosing an outcome. Should return an outcome from the action. If
    not provided, the first outcome in the list will be chosen.
    @param {String} align (optional) - The CSS text-align value for the
    link associated with this action. Defaults to 'left'.
    */
    s.List.call(this);
    this._displayText = text;

    if (checkFunc === undefined || checkFunc === true)  {
        this._userScriptCheck = function() {
            return true;
        }
    } else if (checkFunc === false) {
        this._userScriptCheck = function() {
            return false;
        }
    } else {
        this._userScriptCheck = checkFunc;
    }
    if (typeof(checkFunc) === 'boolean') {
        checkFunc = function() {
            return checkFunc;
        }
    }

    this._userScriptChoose = chooseFunc || function() {
        if (this.length() > 0) {
            return this._array[0];
        } else {
            return null;
        }
    }
    this._align = 'left';
    return this;
};

s.Action.prototype = Object.create(s.List.prototype);

Object.defineProperty(s.Action.prototype, 'constructor', {
    value: s.Action,
    enumerable: false,
    writable: true
});

s.Action.prototype._verify = function(obj) {
    /*
    @override

    Members of an `Action` must be Outcome objects.
    */
    return (obj instanceof s.Outcome);
}

s.Action.prototype.getText = function() {
    return this._displayText;
}

s.Action.prototype.getAlign = function() {
    return this._align;
}

s.Action.prototype.setAlign = function(align) {
    this._align = align;
    return this;
}

s.Action.prototype.check = function() {
    return this._userScriptCheck();
}

s.Action.prototype.choose = function() {
    return this._userScriptChoose();
}
/* twine-user-script #5: "0050-Node.js" */
s.nodes = new Map(); // maps SugarCube `Passage` objects to associated
                     // `Node` objects

s.getNode = function(psgTitle) {
    /*
    Returns the Node object associate with the passage titled,
    `psgTitle`.
    */
    return s.nodes.get(Story.get(psgTitle));
}

s.specialPsgs = [
    'PassageDone', 'PassageFooter', 'PassageHeader', 'PassageReady',
    'StoryAuthor', 'StoryBanner', 'StoryCaption', 'StoryInit',
    'StoryInterface', 'StoryMenu', 'StorySettings', 'StoryShare',
    'StorySubtitle', 'StoryTitle'
];

s.Node = function(psgTitle, subCount, func) {
    /*
    A `Node` object is like a wrapper around a passage. It contains the
    passage which holds the narrative description of the situation, as
    well as a list of possible actions for the reader to choose from.

    Structurally, a node is a list of actions with a passage for the
    narrative description, and some additional methods. As such, it is
    implemented as a subclass of `List`.

    The associated passage may have slots available for dynamically
    generated text substitutions. The node object has properties and
    methods for managing this. The `subCount` property should match the
    number of available text substitutions. It is there for a redundancy
    check to prevent the error of sending the wrong number of text
    substitutions when loading a node.

    Node objects, and their associated Action and Outcome objects,
    should be built on `s` so they are not stored in the player's local
    storage. As such, they will not be saved from session to session, so
    they should not be changed dynamically during gameplay.

    @param {String} psgTitle - The title of the associated passage.
    @param {Integer} subCount - The number of expected text
    substitutions. Defaults to 0.
    @param {Function} func (optional) - The function to call when the
    node is loaded. It runs immediately before the loading of the
    passage associated with the calling node. By default, it does
    nothing.

    @property passage - The SugarCube `Passage` object whose title is
    `psgTitle`
    */
    s.List.call(this);
    if (!Story.has(psgTitle)) {
        throw new Error(
            'Node():\n' +
            'there is no passage titled "' + psgTitle + '"'
        );
    }
    if (s.specialPsgs.indexOf(psgTitle) >= 0) {
        throw new Error(
            'Node():\n' +
            'cannot assign a special passage other than `Start` to a node'
        );
    }
    var psg = Story.get(psgTitle);
    if (s.nodes.has(psg)) {
        throw new Error(
            'Node():\n' +
            'the passage "' + psgTitle + '" already belongs to a node'
        );
    }
    this._passage = psg;
    s.nodes.set(psg, this);
    this._subCount = subCount || 0;
    this._userScript = func || function() {
        return;
    }
    return this;
};

s.Node.prototype = Object.create(s.List.prototype);

Object.defineProperty(s.Node.prototype, 'constructor', {
    value: s.Node,
    enumerable: false,
    writable: true
});

s.Node.prototype._verify = function(obj) {
    /*
    @override

    Members of a `Node` must be actions that are registered with the
    factory.
    */
    return (obj instanceof s.Action);
}

s.Node.prototype.getPassage = function() {
    return this._passage;
}

s.Node.prototype.getSubCount = function() {
    return this._subCount;
}

s.Node.prototype.onLoad = function() {
    return this._userScript();
}

s.Node.prototype.addLink = function(text, psgTitle, func) {
    /*
    Creates a new Outcome that runs the given function, then loads the
    node associated with the given passage title. Then adds that Outcome
    to a new Action with the given text as its link text. Then adds that
    Action to the node.

    If there is no node associated with the given passage title, one
    will be created.

    Returns the newly created action.
    */
    var targetNode = s.nodes.get(Story.get(psgTitle));
    if (targetNode === undefined) {
        targetNode = new s.Node(psgTitle);
    }

    var outcome;
    if (func === undefined) {
        outcome = new s.Outcome(function() {
            v.page.load(targetNode);
        });
    } else {
        outcome = new s.Outcome(function() {
            func();
            v.page.load(targetNode);
        });
    }

    var action = new s.Action(text).push(outcome);
    this.push(action);
    return action;
}
/* twine-user-script #6: "0060-Parser.js" */
/*
A Parser object manages the conversion of the given passage text to the
actual passage text used by SugarCube to display information.

There is one instance (see Global.js), built on State.variables, so its
state can be stored in SugarCube's history. (This is needed, because the
parser tracks dynamically generated text substitutions.) The class must
therefore be made compatible with SugarCube by having `clone()` and
`toJSON()` methods, and no recursive objects or object sharing. To
achieve this, we also require it to have a constructor with no arguments
and to have all its properties be SC supported types.

There are various methods for processing different kinds of markup. The
method, `procMarkup()`, runs them all in the appropriate order. Through
`Config.passages.onProcess`, we instruct SugarCube to apply
`procMarkup()` to passage text whenever a passage is rendered.
*/

s.Parser = function() {
    this._textSubMap = new Map(); // Maps passage titles to arrays of
                                  // text subs.
    return this;    
};

s.Parser.prototype._init = function(obj) {
    /* Needed for SugarCube compatibility. */
    Object.keys(obj).forEach(function (pn) {
        this[pn] = clone(obj[pn]);
    }, this);
    return this;
};

s.Parser.prototype.clone = function () {
    /* Needed for SugarCube compatibility. */
    return (new s.Parser())._init(this);
};

s.Parser.prototype.toJSON = function () {
    /* Needed for SugarCube compatibility. */
    var newPC = {};
    Object.keys(this).forEach(function (pn) {
        newPC[pn] = clone(this[pn]);
    }, this);
    return JSON.reviveWrapper(
        '(new s.Parser())._init($ReviveData$)', newPC
    );
};

s.Parser.prototype.getSubs = function(psgTitle) {
    return this._textSubMap.get(psgTitle);
}

s.Parser.prototype.setSubs = function(psgTitle, subArray) {
    /*
    Adds `psgTitle` key to `_textSubMap` with value `subArray`. Throws
    an error if `psgTitle` doesn't correspond to a node, length of
    `subArray` does match the sub count of the node, or `subArray` is
    not a string array. Returns the calling Parser object.
    */
    var node = s.getNode(psgTitle);
    if (node === undefined) {
        throw new Error(
            'Parser.setSubs():\n' +
            '"' + psgTitle + '" does not correspond to a node.'
        );
    }
    if (node.getSubCount() !== subArray.length) {
        throw new Error(
            'Parser.setSubs():\n' +
            'unexpected number of text substitutions'
        );
    }
    if (!subArray.every(function(element) {
        return (typeof(element) === 'string');
    })) {
        throw new Error(
            'Parser.setSubs():\n' +
            'text substitutions must be strings'
        );
    }
    this._textSubMap.set(psgTitle, subArray);
    return this;
}

s.Parser.prototype.insertTextSubs = function(psgTitle, text) {
    /*
    Fetches the array of text substitutions corresponding to `psgTitle`,
    or `[]` if there is no such array, then replaces instances of
    `{<number>}` in the given text with corresponding elements from that
    array.

    Does nothing if the node associated with `psgTitle` has a sub count
    of 0. Throws an error if the sub count doesn't match the length of
    the substitution array, if any index is out of bounds, if any index
    is repeated, or if there are not enough indices. Returns the
    processed text.

    @param {String} psgTitle - The title of the passage being processed.
    This passage title must correspond to a node. Passing a title that
    does not correspond to a node could have unexpected behavior.
    @param {String} text - The text to process.
    */
    var subArray = (this.getSubs(psgTitle) || []);
    var psg = Story.get(psgTitle);
    var node = s.nodes.get(psg);
    var subCount = node.getSubCount();
    if (subCount === 0) {
        return text;
    }

    var psgId = psg.domId;
    var subsFound = new Set();
    var regex = /\{(\d+?)\}/;
    var processedText = text;
    var result, index;
    while (true) {
        result = regex.exec(processedText);
        if (result === null) {
            if (subsFound.size < subCount) {
                throw new Error(
                    'too few text substitutions in passage, "' +
                    psgTitle + '"'
                );
            }
            return processedText;
        }
        index = parseInt(result[1], 10);
        if (index >= subCount) {
            throw new Error(
                'text substitution index out of range in passage, "' +
                psgTitle + '"'
            );
        }
        if (subsFound.has(index)) {
            throw new Error(
                'duplicate text substitution index in passage, "' +
                passage.title + '"'
            );
        }
        subsFound.add(index);
        processedText = (
            processedText.slice(0, result.index) +
            subArray[index] +
            processedText.slice(result.index + result[0].length)
        );
    }
}

s.Parser.prototype.showDetails = function(description, id) {
    /*
    Inserts the given description into the element with the given id and
    clears all other elements with class `.description`. If the element
    with the given id already contains the given description, the
    function simply clears it.

    @param {String} description - the description to insert
    @param {String} id - the id of the containing element
    */
    var text = jQuery("#" + id).html();     // store the current content
                                            // for comparison

    jQuery(".description").empty()          // clear all elements

    jQuery("#" + id).wiki(description);     // insert the description

    if (text === jQuery("#" + id).html()) { // empty content if already
        jQuery("#" + id).empty();           // present
    }

    return;
}

s.Parser.prototype.procDetailMarkup = function(psgTitle, text) {
    /*
    Replaces instances of `{<link text>|id}` in text with links that
    reveal a description. The description is found in a corresponding
    instance of `{?id|description}` which is replaced by a div element
    into which the description appears. The html id of the div element
    is determined by both the id in the markup and the given `psgTitle`.
    The appearance of the description is controlled by the method
    `Parser.showDetails()`.

    The link text cannot begin with a `?` and cannot contain a `|`. The
    id must contain only letters, numbers, and `_`, and must begin with
    a letter.

    @param {String} psgTitle - The title of the passage being processed.
    @param {String} text - The text of the passage being processed.
    */
    var psg = Story.get(psgTitle);
    var psgId = psg.domId;

    var linkRegex = /\{(.+?)\|([a-zA-Z][0-9a-zA-Z_]*?)\}/;

    var processedText = text;

    var cut = [0,0,0,0];         // indices at which to cut the given
                                 // text

    var part = ['','','','','']; // substrings to concatenate in order
                                 // to build the new text

    var j;                       // temporary storage, used in building
                                 // `cut`

    var linkResult, linkText, linkId, elementId;
    var descRegex, descResult, descText, descLoc;
    while (true) {
        linkResult = linkRegex.exec(processedText);

        if (linkResult === null) {
            if (/\{\?([a-zA-Z][0-9a-zA-Z_]*?)\|(.+?)\}/.test(processedText)) {
                throw new Error(
                    'description markup without link markup in passage, "' +
                    psgTitle + '"'
                );
            }
            return processedText;
        }
        
        linkId = linkResult[2];
        descRegex = new RegExp(
            '\\{\\?' + linkId + '\\|(.+?)\\}'
        );
        descResult = descRegex.exec(processedText);

        if (descResult === null) {
            throw new Error(
                'link markup without description markup in passage, "' +
                psgTitle + '"'
            );
        }

        linkText = linkResult[1];
        descText = descResult[1];
        elementId = psgId + '-examine-' + linkId;

        j = linkResult.index < descResult.index ? 0 : 2;
        cut[j] = linkResult.index;
        cut[j+1] = linkResult.index + linkResult[0].length;
        cut[2-j] = descResult.index;
        cut[3-j] = descResult.index + descResult[0].length;

        part[0] = processedText.slice(0, cut[0]);
        part[2] = processedText.slice(cut[1], cut[2]);
        part[4] = processedText.slice(cut[3])

        part[j+1] = (
            '<<link "' + linkText + '">>' +
                '<<run v.parser.showDetails(' + 
                    '"' + descText + '", "' + elementId + '"' +
                ')>>' +
            '<</link>>'
        );

        part[3-j] = (
            '<div id="' + elementId + '" class="description">' +
            '</div>'
        );

        processedText = part.join('');
    }
}

s.Parser.prototype.addContainers = function(psgTitle, text) {
    /*
    Wraps the given text in a `body` container; adds an `action`
    container for the action links; adds a `next` container in case the
    next node is to be loaded without a passage transition. The html id
    of the containers is determined by `psgTitle`.

    @param {String} psgTitle - The title of the passage being processed.
    This passage title must correspond to a node. Passing a title that
    does not correspond to a node could have unexpected behavior.
    @param {String} text - The text to process.
    */
    var psg = Story.get(psgTitle);
    return (
        '<div id="' + psg.domId + '-body">\n\n' +
            text + '\n\n' +
        '</div>\n\n' + 
        '<div id="' + psg.domId + '-actions"></div>\n\n' +
        '<div id="' + psg.domId + '-next"></div>'
    );

}

s.Parser.prototype.removeBreaks = function(text) {
    /*
    Removes line breaks from the given text.
    */
    var processedText = text.replace(/\r/g, '');
    processedText = processedText.replace(/^\n+|\n+$/g, '');
    processedText = processedText.replace(/\n+/g, ' ');
    return processedText;
}

s.Parser.prototype.procAllMarkup = function(psgTitle, text) {
    /*
    Processes the special node markup in the given passage (inserts text
    subs, processes the detail markup, adds the containers, and removes
    breaks. Does nothing if the given passage is not associated with a
    node. Returns the processed text.

    @param {String} psgTitle - The title of the passage being processed.
    @param {String} text - The text of the passage being processed.
    */
    var node = s.nodes.get(Story.get(psgTitle));
    if (node === undefined) {
        return text;
    }

    var processedText = text;
    processedText = this.insertTextSubs(psgTitle, processedText);
    processedText = this.procDetailMarkup(psgTitle, processedText);
    processedText = this.addContainers(psgTitle, processedText);
    processedText = this.removeBreaks(processedText);

    return processedText;
}
/* twine-user-script #7: "0070-Page.js" */
/*
A `Page` object represents the content which is displayed on the screen.
Traditionally in SugarCube, this is just a passage. But with the node
system, multiple passages can be displayed at a time, in order. The
first passage is the main one and the one which SugarCube regards as
being displayed. The other passages are displayed inside the first
passage.

There is one instance (`v.page`, see Global.js), built on
State.variables, so its state can be stored in SugarCube's history.
(This allows SugarCube to rebuild the page upon a browser refresh or
upon loading a save file.) The class must therefore be made compatible
with SugarCube by having `clone()` and `toJSON()` methods, and no
recursive objects or object sharing. To achieve this, we also require it
to have a constructor with no arguments and to have all its properties
be SC supported types.
*/

s.Page = function() {
    this._embeddedPsgs = [];  // list of embedded passage titles; does
                              // not include the first (main) passage
    this._continuous = false; // set true to have passages embed by
                              // default
    return this;    
};

s.Page.prototype._init = function(obj) {
    /* Needed for SugarCube compatibility. */
    Object.keys(obj).forEach(function (pn) {
        this[pn] = clone(obj[pn]);
    }, this);
    return this;
};

s.Page.prototype.clone = function () {
    /* Needed for SugarCube compatibility. */
    return (new s.Page())._init(this);
};

s.Page.prototype.toJSON = function () {
    /* Needed for SugarCube compatibility. */
    var newPC = {};
    Object.keys(this).forEach(function (pn) {
        newPC[pn] = clone(this[pn]);
    }, this);
    return JSON.reviveWrapper(
        '(new s.Page())._init($ReviveData$)', newPC
    );
};

s.Page.prototype.isContinuous = function() {
    return this._continuous;
}

s.Page.prototype.setContinuous = function(val) {
    this._continuous = val;
    return this;
}

s.Page.prototype.insertActions = function(psg) {
    /*
    For each action in the node corresponding to the given SC passage
    object, this function checks if the action should be displayed. If
    it passes the check, it adds a link for the corresponding action.
    Does nothing if the incoming passage does not correspond to a node.
    */
    var node = s.nodes.get(psg);
    if (node === undefined) {
        return;
    }

    var psgTitle = psg.title;
    var psgId = psg.domId;
    var action;
    for (var i = 0; i < node.length(); i++) {
        action = node.get(i);
        if (action.check()) {
            $('#' + psgId + '-actions').wiki(
                '<p style="text-align:' + action.getAlign() + '">' +
                    '<<link "' + action.getText() + '">>'+
                        '<<run s.nodes.get(Story.get("' + psgTitle + '"))' +
                        '.get(' + i + ').choose().carryOut()>>' +
                    '<</link>>' +
                '</p>'
            );
        }
    }
    return this;
}

s.Page.prototype.innerPsg = function() {
    /*
    Returns the innermost passage on the page as a SC Passage object.
    */
    var psg;
    if (this._embeddedPsgs.length === 0) {
        psg = Story.get(passage());
    } else {
        var title = this._embeddedPsgs[this._embeddedPsgs.length - 1];
        psg = Story.get(title);
    }
    return psg;
}

s.Page.prototype.scrollToLast = function() {
    /*
    Scrolls to put the innermost passage at the top.
    */
    $('html, body').animate({
        scrollTop: $('#' + this.innerPsg().domId + '-body').position().top
    }, 0);
    return this;
}

s.Page.prototype.insertPsg = function(psg, shellPsg) {
    /*
    Inserts the given passage into the given shell passage.

    @param {<<SC Passage object>>} psg - The passage to embed.
    @param {<<SC Passage object>>} shellPsg - The passage into which to
    embed.
    */
    $('#' + shellPsg.domId + '-next').wiki(
        '<p style="text-align:center">****</p>' +
        v.parser.procAllMarkup(psg.title, psg.text)
    );
    return this;
}

s.Page.prototype.embedPsg = function(node) {
    /*
    Removes the current actions from the page, inserts the given node
    and its actions into the bottom of the page, scrolls to put the new
    content at the top, appends the page's list of embedded passages,
    and adds a new moment to SC's history.
    */
    var nodePsg = node.getPassage();
    if (nodePsg.title === passage() ||
        this._embeddedPsgs.indexOf(nodePsg.title) >= 0) {
        throw new Error(
            'Page.load():\n' +
            'cannot embed a passage in itself'
        );
    }

    var latestPsg = this.innerPsg();
    $('#' + latestPsg.domId + '-actions').empty();
    this.insertPsg(nodePsg, latestPsg);
    this.insertActions(nodePsg);
    this.scrollToLast();
    this._embeddedPsgs.push(nodePsg.title);
    State.create(State.passage);
    return this;
}

s.Page.prototype.load = function(node, embed) {
    /*
    Runs the given node's `onLoad` function, then renders the node's
    passage. If the optional parameter `embed` is true, then rather than
    rendering the passage, the passage's contents are appended to the
    end of the last embedded passage, the page is scrolled to put the
    new passage content at the top, and a new moment is added to SC's
    history.
    */
    embed = embed || this._continuous;
    node.onLoad();
    var nodePsg = node.getPassage();
    if (embed) {
        this.embedPsg(node);
        return this;
    } else {
        this._embeddedPsgs = [];
        Engine.play(nodePsg.title);
        return this;
    }
}

s.Page.prototype.reEmbedPsgs = function(psg) {
    /*
    Re-embeds embedded passages when the given main containing passage
    object renders.
    */
    var currentPsg = psg;
    var nextPsg;
    for (var i = 0; i < this._embeddedPsgs.length; i++) {
        nextPsg = Story.get(this._embeddedPsgs[i]);
        this.insertPsg(nextPsg, currentPsg);
        currentPsg = nextPsg;
    }
    return this;
}

s.Page.prototype.rebuildPage = function(psg) {
    /*
    To be run after the given main containing passage object renders.
    Re-embeds embedded passages.  Inserts action links into last
    embedded passage, then scrolls so that the last embedded passage is
    the first thing visible.

    @param {SC Passage object} psg
    */
    var currentPsg = this.innerPsg();
    this.reEmbedPsgs(psg);
    this.insertActions(currentPsg);
    this.scrollToLast();
    return this;
}
/* twine-user-script #8: "8000-Global.js" */
/*
Global objects scattered throughout code:
----
from Node.js:
    s.nodes : Map(<<SC Passage obj>> : Node)
    s.getNode(psgTitle: String): Node
    s.specialPassages : String[]
*/

Config.passages.nobr = true; // sets all passages to `nobr`

window.onerror = function(msg, url, linenumber) {
    /*
    Ensures that errors appear in a pop-up for greater visibility. Works
    in Firefox, but doesn't seem to work in Safari. Be sure to do
    testing in Firefox.
    */
    alert(
        'Error message: ' + msg + '\n' +
        'URL: ' + url + '\n' +
        'Line Number: ' + linenumber
    );
    return true;
}

s.makeLink = function(startPsgTitle, text, endPsgTitle, func) {
    /*
    Calls the `addLink` method of the node associated with
    `startPsgTitle`, passing it the other parameters. If no such node
    exists, one is created.
    */
    var startNode = s.nodes.get(Story.get(startPsgTitle));
    if (startNode === undefined) {
        startNode = new s.Node(startPsgTitle);
    }

    return startNode.addLink(text, endPsgTitle, func);
}

v.parser = new s.Parser();

Config.passages.onProcess = function (p) {
    var processedText = v.parser.procAllMarkup(p.title, p.text);
    return processedText;
};

v.page = new s.Page();

$(window).on('beforeunload', function(){
    State.metadata.set('reloading', true);
    return;
});

s.rebuildPage = function(ev) {
    /*
    Pauses before rebuilding page if page was just reloaded. Otherwise,
    the scrollToLast method executes too soon and has no effect.
    */
    if (State.metadata.get('reloading')) {
        setTimeout(function() {
            v.page.rebuildPage(ev.passage);
            return;
        }, 500);
        State.metadata.set('reloading', false);
    } else {
        v.page.rebuildPage(ev.passage);
    }
    return;
}

$(document).on(':passagedisplay', s.rebuildPage);
/* twine-user-script #9: "9000-Main.js" */
v.page.setContinuous(true);

s.makeLink('Start', 'begin', 'intro').setAlign('center');
s.makeLink('intro', 'continue', 'RNG warning');
s.makeLink('RNG warning', 'got it', 'who you are');
s.makeLink('who you are', 'take a look around', 'bedroom');

s.getNode('bedroom').push((new s.Action(
    'take the knife',
    function() {
        return (v.containedIn.get('knife') === 'bedroom');
    }
)).push(new s.Outcome(function() {
    v.containedIn.delete('knife');
    v.inventory.add('knife');
    v.parser.setSubs('Taking knife', [' You may need this for later.']);
    v.page.load(s.takingKnife, true);
    return;
})));

s.getNode('bedroom').push((new s.Action(
    'search the body',
    function() {
        return !v.body.searched;
    }
)).push(new s.Outcome(function() {
    v.body.searched = true;
    v.parser.setSubs('Cops bust in', [
        '',

        'As you bend down to take a closer look at the body, the bedroom ' +
        'door bursts open. ' 
    ]);
    v.page.load(s.copsBustIn, true);
    return;
})));



s.copsBustIn = new s.Node('Cops bust in', 2, function() {
    v.detective.discovered = true;
    return;
});



s.takingKnife = new s.Node('Taking knife', 1);

s.bedroom = s.getNode('bedroom')
for (var i = 0; i < s.bedroom.length(); i++) {
    s.takingKnife.push(s.bedroom.get(i));
}

s.makeLink('Cops bust in', 'continue', 'Next');
/* twine-user-script #10: "Story JavaScript" */


:: StorySubtitle
Story Subtitle


:: StoryAuthor
Story Author


:: StoryBanner
Story Banner


:: StoryCaption
Story Caption


:: StoryMenu
<<link 'menu item 1'>><</link>>
<<link 'menu item 2'>><</link>>


:: StoryInit
<<set $pounding = true>>
<<set $crowbar = false>>
<<set $knowledge = new Set()>>
<<set $containedIn = new Map()>>
<<run $containedIn.set("knife", "bedroom")>>
<<set $body = {
    searched: false
}>>
<<set $detective = {
    discovered: false
}>>
<<set $inventory = new Set()>>


:: Start
<div style='text-align:center'>
    <h1><<= Story.title>></h1>
    by<br>
    <<= Story.get('StoryAuthor').text>><br>
    <br>
    <br>
    <br>
</div>


:: intro
<p>It started with one shot of whiskey. Of course, most nights started with one shot of whiskey. Then one became two and two became more. Before long, you were making a fool of yourself. At least you assume you were. You can't remember.</p>

<p>That was last night. This morning, you wake up alone on a strange bed in a house you've never seen before. From the trash and bottles lying around, this had to be the scene of some after-party. But where is everyone? And what is that smell? It's then you realize your clothes are covered in blood.</p>

<p>When you get out of the bed, you see it. The body. A man lying on his back, dead, with a knife sticking out of his chest. Before you can do or think anything, someone starts pounding on the front door. Is it the police? Is it the murderer? Are //you// the murderer?</p>


:: RNG warning
<p>In this story, your choices can have random consequences. The chances of the various outcomes are affected by your character's traits. You can read about those traits on the Character Sheet. The Character Sheet also shows what you are carrying, what you have learned, and any injuries you may have suffered.</p>


:: who you are
<p>Scott Allen Brady. Scotty, to your friends. That's your name. You have to remind yourself, just to make sure you haven't forgotten //everything//. The last thing you remember is leaving work. You'd finished packing the motherboards into their shipping crates. Then you clocked out and left the plant. You were still wearing your Hewlett-Packard shirt when you got in your truck. You met some friends at the bar. Then...</p>

<p>Nothing. You can't remember. Now here you are, in some surreal nightmare, looking at a dead guy. The pounding on the door makes it hard to concentrate.</p>


:: bedroom
<p>You are in what has to be the master bedroom. You reek of alcohol, your mouth is dry and tastes like vomit, and your head is throbbing. There's blood on your clothes, in your hair, and on your face and hands. You've had better days.</p>

<p>You're wearing a white T-shirt with the Seattle Seahawks logo on the front. But you can hardly see the logo under all the blood. Your jeans are also caked with dried blood.</p>

<p>On your left, the {bedroom door|A} is closed. <<if $pounding>>You can hear the pounding on the front door coming from that direction. <<elseif $crowbar>>Outside the bedroom, <<if $knowledge.has("policeAtDoor")>>the police are<<else>>someone is<</if>> breaking into the house with a crowbar. <</if>>To your right, the {door|B} to the adjoining bathroom is ajar. On the floor is a {dead man|C}, lying on his back in a pool of blood. <<if $containedIn.get("knife") == "bedroom">>What looks like a heavy-duty {chef's knife|D} is sticking out of his chest.<</if>></p>

{?A|<p>The bedroom door is white, like the walls of the room. Blood is spattered on the left side near the door handle.</p>}

{?B|<p>The bathroom door is made of cheap plywood and won't even close all the way.</p>}

{?C|<p>You've never seen the dead man before, as far as you can remember. He must be in his mid-thirties.</p>}

{?D|<p>The murder weapon looks like the kind of knife they have hanging on the wall in a restaurant kitchen--the kind they use to cut meat or chop big vegetables. It has a wide blade and is about a foot long.</p>}


:: Cops bust in
<p>{0}</p>

<p>{1}Three men rush in. "Get down on the ground!" one shouts. <<if $inventory.has("knife")>>"He's got a knife!" yells another.<</if>> They all have their guns trained on you. The bald man in the center looks like a police {detective|A}. The other two are uniformed cops.</p>

{?A|The detective doesn't move. He doesn't blink. He just stands there scowling, waiting for you to make a move.}


:: Taking knife
<p>You take the knife and carefully slide it under your belt.{0}</p>


:: Next
To be continued.


