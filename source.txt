:: StoryTitle
Story Title


:: StoryData
{
	"ifid": "5406BF44-CF93-41CF-9DED-9824A52E2F82",
	"format": "SugarCube",
	"format-version": "2.30.0",
	"start": "Start",
	"zoom": 1
}


:: Story Stylesheet [stylesheet]
html {
    font: 100% Georgia, serif;
}
body {
    color: white;
    background-color: black;
}
a {
    cursor: pointer;
    color: #68d;
    text-decoration: none;
    font-weight: bold;
    transition-duration: 200ms;
}
.description {
  color: yellow;
}


:: Story JavaScript [script]
/* twine-user-script #1: "0010-standard.js" */
/*
Establishes shorthand aliases for the following namespaces in
SugarCube: `setup`, `settings`, `State.variables`, and
`State.temporary`.

All classes and functions are built on the `s` namespace. All instances
are built on the `v` namespace.
*/

Object.defineProperty(window, "s", {
    get: function() {
        return setup;
    }
});

Object.defineProperty(window, "ss", {
    get: function() {
        return settings;
    }
});

Object.defineProperty(window, "v", {
    get: function() {
        return State.variables;
    }
});

Object.defineProperty(window, "t", {
    get: function() {
        return State.temporary;
    }
});

Config.passages.nobr = true; // sets all passages to `nobr`

window.onerror = function(msg, url, linenumber) {
    /*
    Ensures that errors appear in a pop-up for greater visibility. Works
    in Firefox, but doesn't seem to work in Safari. Be sure to do
    testing in Firefox.
    */
    alert(
        'Error message: ' + msg + '\n' +
        'URL: ' + url + '\n' +
        'Line Number: ' + linenumber
    );
    return true;
}
/* twine-user-script #2: "0020-List.js" */
s.List = function() {
    /*
    A wrapper around an array with methods for controlling manipulation
    and access of elements.
    */
    this._array = [];
    return this;
}

s.List.prototype._verify = function(obj) {
    /*
    Checks if `obj` qualifies to be in the list. Should be overwritten
    by subclasses.
    */
    return true;
}

s.List.prototype.push = function() {
    /*
    Takes any number of objects as parameters. If any given object
    fails the `_verify` test, throws an error. Otherwise, adds all
    objects to `_array` and returns the calling `List` object.
    */
    if (arguments.length > 0) {
        var args = Array.prototype.slice.call(arguments);
        var arg = args.shift();
        if (this._verify(arg)) {
            this._array.push(arg);
        } else {
            throw new Error(
                'List.push():\n' +
                'object does not qualify for list'
            );
        }
        this.push.apply(this, args);
    }
    return this;
}

s.List.prototype.delete = function(index) {
    /*
    Deletes the list element at the given index and returns the modified
    `List` object. Throws an error if index is out of range. Returns the
    calling `List` object.
    */
    if (index !== parseInt(index, 10) || index < 0 ||
        index >= this._array.length) {
        throw new Error(
            'List.delete():\n' +
            'invalid index'
        );
    }
    this._array.splice(index, 1);
    return this;
}

s.List.prototype.get = function(index) {
    return this._array[index];
}

s.List.prototype.indexOf = function(obj) {
    return this._array.indexOf(obj);
}

s.List.prototype.length = function() {
    return this._array.length;
}
/* twine-user-script #3: "0030-Outcome.js" */
s.Outcome = function(func) {
    /*
    Represents one possible result of a player action.

    @param {Function} func - The function to call when the outcome is
    carried out.
    */
    this._userScript = func;
    return this;
}

s.Outcome.prototype.carryOut = function() {
    return this._userScript();
}
/* twine-user-script #4: "0040-Action.js" */
s.Action = function(text, chooseFunc, checkFunc) {
    /*
    In a given passage, the reader will choose from a list of actions.
    Each action can be displayed as a link, and when it is selected,
    the story will choose from a list of that action's possible
    outcomes. An `Action` object represents one of these actions.

    Structurally, an action object is a list of outcomes with a display
    text for the link, and some additional methods available. As such,
    it is implemented as a subclass of `List`.

    @param {String} text - The text to appear in the link.
    @param {Function} chooseFunc (optional) - The function to call when
    choosing an outcome. Should return an outcome from the action. If
    not provided, the first outcome in the list will be chosen.
    @param {Function} checkFunc (optional) - The function to call when
    checking if the action should be displayed. Should return a boolean.
    If not provided, simply returns true.
    */
    s.List.call(this);
    this._displayText = text;
    this._userScriptChoose = chooseFunc || function() {
        if (this.length() > 0) {
            return this._array[0];
        } else {
            return null;
        }
    }
    this._userScriptCheck = checkFunc || function() {
        return true;
    }
    return this;
};

s.Action.prototype = Object.create(s.List.prototype);

Object.defineProperty(s.Action.prototype, 'constructor', {
    value: s.Action,
    enumerable: false,
    writable: true
});

s.Action.prototype._verify = function(obj) {
    /*
    @override

    Members of an `Action` must be Outcome objects.
    */
    return (obj instanceof s.Outcome);
}

s.Action.prototype.getText = function() {
    return this._displayText;
}

s.Action.prototype.check = function() {
    return this._userScriptCheck();
}

s.Action.prototype.choose = function() {
    return this._userScriptChoose();
}
/* twine-user-script #5: "0050-Node.js" */
s.nodes = new Map(); // maps SugarCube `Passage` objects to associated
                     // `Node` objects

s.specialPassages = [
    'PassageDone', 'PassageFooter', 'PassageHeader', 'PassageReady',
    'StoryAuthor', 'StoryBanner', 'StoryCaption', 'StoryInit',
    'StoryInterface', 'StoryMenu', 'StorySettings', 'StoryShare',
    'StorySubtitle', 'StoryTitle'
]

s.Node = function(psgTitle, subCount, func) {
    /*
    A `Node` object is like a wrapper around a passage. It contains the
    passage which holds the narrative description of the situation, as
    well as a list of possible actions for the reader to choose from.

    Structurally, a node is a list of actions with a passage for the
    narrative description, and some additional methods. As such, it is
    implemented as a subclass of `List`.

    The associated passage may have slots available for dynamically
    generated text substitutions. The node object has properties and
    methods for managing this. The `subCount` property should match the
    number of available text substitutions. It is there for a redundancy
    check to prevent the error of sending the wrong number of text
    substitutions when loading a node.

    Node objects, and their associated Action and Outcome objects,
    should be built on `s` so they are not stored in the player's local
    storage. As such, they will not be saved from session to session, so
    they should not be changed dynamically during gameplay.

    @param {String} psgTitle - The title of the associated passage.
    @param {Integer} subCount - The number of expected text
    substitutions. Defaults to 0.
    @param {Function} func (optional) - The function to call when the
    node is loaded. By default, it loads the passage associated with the
    calling node.

    @property passage - The SugarCube `Passage` object whose title is
    `psgTitle`
    */
    s.List.call(this);
    if (!Story.has(psgTitle)) {
        throw new Error(
            'Node():\n' +
            'there is no passage titled "' + psgTitle + '"'
        );
    }
    if (s.specialPassages.indexOf(psgTitle) >= 0) {
        throw new Error(
            'Node():\n' +
            'cannot assign a special passage other than `Start` to a node'
        );
    }
    var passage = Story.get(psgTitle);
    if (s.nodes.has(passage)) {
        throw new Error(
            'Node():\n' +
            'the passage "' + psgTitle + '" already belongs to a node'
        );
    }
    this._passage = passage;
    s.nodes.set(passage, this);
    this._subCount = subCount || 0;
    this._userScript = func || function() {
        Engine.play(this._passage.title);
    }
    return this;
};

s.Node.prototype = Object.create(s.List.prototype);

Object.defineProperty(s.Node.prototype, 'constructor', {
    value: s.Node,
    enumerable: false,
    writable: true
});

s.Node.prototype._verify = function(obj) {
    /*
    @override

    Members of a `Node` must be actions that are registered with the
    factory.
    */
    return (obj instanceof s.Action);
}

s.Node.prototype.getPassage = function() {
    return this._passage;
}

s.Node.prototype.getSubCount = function() {
    return this._subCount;
}

s.Node.prototype.load = function() {
    return this._userScript();
}
/* twine-user-script #6: "0060-node-markup.js" */
/*
This file encodes the special text processing done by the node system on
the passage text. The text substitutions are stored in `v` so that they
are saved in SC's history. They should be set before the incoming node
is loaded.
*/

v.textSubs = [] // The array of text subs for the incoming node.

s.procTextSubContainers = function(psgTitle, psgText) {
    /*
    Replaces instances of `{<number>}` in the passage text with
    `v.textSubs[<number]`. Throws an error if any index is out of
    bounds, if any index is repeated, or if there are not enough
    indices. Returns the processed text.

    @param {String} psgTitle - The title of the passage being processed.
    @param {String} psgText - The text of the passage being processed.
    */
    var passage = Story.get(psgTitle);
    var psgId = passage.domId;

    var node = s.nodes.get(passage);
    var subCount = node.getSubCount();
    var subsFound = 0;

    var regex = /\{(\d+?)\}/;

    var processedText = psgText;
    var result, index;
    while (true) {
        result = regex.exec(processedText);

        if (result === null) {
            if (subsFound < subCount) {
                throw new Error(
                    'too few text substitutions in passage, "' +
                    psgTitle + '"'
                );
            }

            return processedText;
        }

        index = parseInt(result[1], 10);

        if (index >= subCount) {
            throw new Error(
                'text substitution index out of range in passage, "' +
                psgTitle + '"'
            );
        }

        if (processedText.indexOf(v.textSubs[index]) >= 0) {
            throw new Error(
                'duplicate text substitution index in passage, "' +
                passage.title + '"'
            );
        }

        subsFound += 1;
        processedText = (
            processedText.slice(0, result.index) +
            v.textSubs[index] +
            processedText.slice(result.index + result[0].length)
        );
    }
}

s.examine = function(description, id) {
    /*
    Inserts the given description into the element with the given id and
    clears all other elements with class `.description`. If the element
    with the given id already contains the given description, the
    function simply clears it.

    @param {String} description - the description to insert
    @param {String} id - the id of the containing element
    */
    var text = jQuery("#" + id).html();     // store the current content
                                            // for comparison

    jQuery(".description").empty()          // clear all elements

    jQuery("#" + id).wiki(description);     // insert the description

    if (text === jQuery("#" + id).html()) { // empty content if already
        jQuery("#" + id).empty();           // present
    }

    return;
}

s.procExamineLinks = function(psgTitle, psgText) {
    /*
    Replaces instances of `{text|id}` with links that reveal a
    description. The description is found in a corresponding instance of
    `{?id|description}` which is replaced by a div element into which
    the description appears. The appearance of the description is
    controlled by the function `s.examine()`.

    The text in the link markup cannot begin with a `?` and cannot
    contain a `|`. The id in the link markup must contain only letters,
    numbers, and `_`, and must begin with a letter.

    @param {String} psgTitle - The title of the passage being processed.
    @param {String} psgText - The text of the passage being processed.
    */
    var passage = Story.get(psgTitle);
    var psgId = passage.domId;

    var linkRegex = /\{(.+?)\|([a-zA-Z][0-9a-zA-Z_]*?)\}/;

    var processedText = psgText;

    var cut = [0,0,0,0];         // indices at which to cut the given
                                 // text

    var part = ['','','','','']; // substrings to concatenate in order
                                 // to build the new text

    var j;                       // temporary storage, used in building
                                 // `cut`

    var linkResult, linkText, linkId, elementId;
    var descRegex, descResult, descText, descLoc;
    while (true) {
        linkResult = linkRegex.exec(processedText);

        if (linkResult === null) {
            if (/\{\?([a-zA-Z][0-9a-zA-Z_]*?)\|(.+?)\}/.test(processedText)) {
                throw new Error(
                    'description markup without link markup in passage, "' +
                    psgTitle + '"'
                );
            }
            return processedText;
        }
        
        linkId = linkResult[2];
        descRegex = new RegExp(
            '\\{\\?' + linkId + '\\|(.+?)\\}'
        );
        descResult = descRegex.exec(processedText);

        if (descResult === null) {
            throw new Error(
                'link markup without description markup in passage, "' +
                psgTitle + '"'
            );
        }

        linkText = linkResult[1];
        descText = descResult[1];
        elementId = psgId + '-examine-' + linkId;

        j = linkResult.index < descResult.index ? 0 : 2;
        cut[j] = linkResult.index;
        cut[j+1] = linkResult.index + linkResult[0].length;
        cut[2-j] = descResult.index;
        cut[3-j] = descResult.index + descResult[0].length;

        part[0] = processedText.slice(0, cut[0]);
        part[2] = processedText.slice(cut[1], cut[2]);
        part[4] = processedText.slice(cut[3])

        part[j+1] = (
            '<<link "' + linkText + '">>' +
                '<<run s.examine(' + 
                    '"' + descText + '", "' + elementId + '"' +
                ')>>' +
            '<</link>>'
        );

        part[3-j] = (
            '<p><span id="' + elementId + '" class="description">' +
            '</span></p>'
        );

        processedText = part.join('');
    }
}

s.addNodeContainers = function(psgTitle, psgText) {
    /*
    Wraps the passage text in a `body` container; adds an `action`
    container for the action links; adds a `next` container in case the
    next node is to be loaded without a passage transition.
    */
    var passage = Story.get(psgTitle);
    return (
        '<div id="' + passage.domId + '-body">\n\n' +
            psgText + '\n\n' +
        '</div>\n\n' + 
        '<div id="' + passage.domId + '-actions"></div>\n\n' +
        '<div id="' + passage.domId + '-next"></div>'
    );
}

s.procNodeMarkup = function(psgTitle, psgText) {
    /*
    Processes the special node markup in the given passage. Does nothing
    if the given passage is not associated with a node. Returns the
    processed text.

    @param {String} psgTitle - The title of the passage being processed.
    @param {String} psgText - The text of the passage being processed.
    */
    var node = s.nodes.get(Story.get(psgTitle));
    if (node === undefined) {
        return psgText;
    }

    var processedText = psgText;
    processedText = s.procTextSubContainers(psgTitle, processedText);
    processedText = s.procExamineLinks(psgTitle, processedText);
    processedText = s.addNodeContainers(psgTitle, processedText);

    return processedText;
}

Config.passages.onProcess = function (p) {
    return s.procNodeMarkup(p.title, p.text);
};
/* twine-user-script #7: "9000-main.js" */
s.copsBustIn = new s.Node('Cops bust in', 2);
/* twine-user-script #8: "Story JavaScript" */


:: StorySubtitle
Story Subtitle


:: StoryAuthor
Story Author


:: StoryBanner
Story Banner


:: StoryCaption
Story Caption


:: StoryMenu
<<link 'menu item 1'>><</link>>
<<link 'menu item 2'>><</link>>


:: StoryInit
<<set $knife = true>>


:: Start
<<link 'Cops bust in'>>
    <<set $textSubs = [
        "<p>You stare at the dead man on the floor. You are trying to remember something—//anything//—about what happened and how you got here. The last thing you remember was doing shots at the Fireplace Tavern. You were playing pool with a woman you'd met that night. She had this weird tattoo on the top of her hand, above the base of her thumb. It might have been a letter, but it wasn't from our alphabet. Maybe this is her {house|A0}.</p>\n\n" +

        "{?A0|This house is a dump.}",

        "Suddenly, the door bursts open and you jump to your feet. "
    ]>>
    <<goto 'Cops bust in'>>
<</link>>


:: Cops bust in
{0}

<p>{1}Three men rush in. "Get down on the ground!" one shouts. <<if $knife>>"He's got a knife!" yells another. <</if>>They all have their guns trained on you. The bald man in the center looks like a police {detective|A}. The other two are {uniformed cops|B}.</p>

{?A|The detective doesn't move. He doesn't blink. He just stands there scowling, waiting for you to make a move.}

{?B|The uniformed cops look like bumbling stooges.}

"Get on the {ground|C}!" the detective shouts.

{?C|You loathe the idea of lying down in all that blood.}

<p><<link 'View modifed passage text in console'>>
    <<script>>
        var p = Story.get(passage());
        console.log(
            s.procNodeMarkup(p.title, p.text)
        );
    <</script>>
<</link>></p>


