:: StoryTitle
Story Title


:: StoryData
{
	"ifid": "5406BF44-CF93-41CF-9DED-9824A52E2F82",
	"format": "SugarCube",
	"format-version": "2.31.0",
	"start": "Start",
	"zoom": 1
}


:: Story Stylesheet [stylesheet]
html {
    font: 100% Georgia, serif;
}
body {
    color: white;
    background-color: black;
}
a {
    cursor: pointer;
    color: #68d;
    text-decoration: none;
    font-weight: bold;
    transition-duration: 200ms;
}
.description {
  color: yellow;
}


:: Story JavaScript [script]
/* twine-user-script #1: "0010-standard.js" */
/*
Establishes shorthand aliases for the following namespaces in
SugarCube: `setup`, `settings`, `State.variables`, and
`State.temporary`.

All classes and functions are built on the `s` namespace. All instances
are built on the `v` namespace.
*/

Object.defineProperty(window, "s", {
    get: function() {
        return setup;
    }
});

Object.defineProperty(window, "ss", {
    get: function() {
        return settings;
    }
});

Object.defineProperty(window, "v", {
    get: function() {
        return State.variables;
    }
});

Object.defineProperty(window, "t", {
    get: function() {
        return State.temporary;
    }
});
/* twine-user-script #2: "0020-List.js" */
s.List = function() {
    /*
    A wrapper around an array with methods for controlling manipulation
    and access of elements.
    */
    this._array = [];
    return this;
}

s.List.prototype._verify = function(obj) {
    /*
    Checks if `obj` qualifies to be in the list. Should be overwritten
    by subclasses.
    */
    return true;
}

s.List.prototype.push = function() {
    /*
    Takes any number of objects as parameters. If any given object
    fails the `_verify` test, throws an error. Otherwise, adds all
    objects to `_array` and returns the calling `List` object.
    */
    if (arguments.length > 0) {
        var args = Array.prototype.slice.call(arguments);
        var arg = args.shift();
        if (this._verify(arg)) {
            this._array.push(arg);
        } else {
            throw new Error(
                'List.push():\n' +
                'object does not qualify for list'
            );
        }
        this.push.apply(this, args);
    }
    return this;
}

s.List.prototype.delete = function(index) {
    /*
    Deletes the list element at the given index and returns the modified
    `List` object. Throws an error if index is out of range. Returns the
    calling `List` object.
    */
    if (index !== parseInt(index, 10) || index < 0 ||
        index >= this._array.length) {
        throw new Error(
            'List.delete():\n' +
            'invalid index'
        );
    }
    this._array.splice(index, 1);
    return this;
}

s.List.prototype.get = function(index) {
    return this._array[index];
}

s.List.prototype.indexOf = function(obj) {
    return this._array.indexOf(obj);
}

s.List.prototype.length = function() {
    return this._array.length;
}
/* twine-user-script #3: "0030-Outcome.js" */
s.Outcome = function(func) {
    /*
    Represents one possible result of a player action.

    @param {Function} func - The function to call when the outcome is
    carried out.
    */
    this._userScript = func;
    return this;
}

s.Outcome.prototype.carryOut = function() {
    return this._userScript();
}
/* twine-user-script #4: "0040-Action.js" */
s.Action = function(text, checkFunc, chooseFunc) {
    /*
    In a given passage, the reader will choose from a list of actions.
    Each action can be displayed as a link, and when it is selected,
    the story will choose from a list of that action's possible
    outcomes. An `Action` object represents one of these actions.

    Structurally, an action object is a list of outcomes with a display
    text for the link, and some additional methods available. As such,
    it is implemented as a subclass of `List`.

    @param {String} text - The text to appear in the link.
    @param {Function|Boolean} checkFunc (optional) - The function to
    call when checking if the action should be displayed. Should return
    a boolean. If a boolean is provided, simply returns that boolean.
    Defaults to true.
    @param {Function} chooseFunc (optional) - The function to call when
    choosing an outcome. Should return an outcome from the action. If
    not provided, the first outcome in the list will be chosen.
    @param {String} align (optional) - The CSS text-align value for the
    link associated with this action. Defaults to 'left'.
    */
    s.List.call(this);
    this._displayText = text;

    if (checkFunc === undefined || checkFunc === true)  {
        this._userScriptCheck = function() {
            return true;
        }
    } else if (checkFunc === false) {
        this._userScriptCheck = function() {
            return false;
        }
    } else {
        this._userScriptCheck = checkFunc;
    }
    if (typeof(checkFunc) === 'boolean') {
        checkFunc = function() {
            return checkFunc;
        }
    }

    this._userScriptChoose = chooseFunc || function() {
        if (this.length() > 0) {
            return this._array[0];
        } else {
            return null;
        }
    }
    this._align = 'left';
    return this;
};

s.Action.prototype = Object.create(s.List.prototype);

Object.defineProperty(s.Action.prototype, 'constructor', {
    value: s.Action,
    enumerable: false,
    writable: true
});

s.Action.prototype._verify = function(obj) {
    /*
    @override

    Members of an `Action` must be Outcome objects.
    */
    return (obj instanceof s.Outcome);
}

s.Action.prototype.getText = function() {
    return this._displayText;
}

s.Action.prototype.getAlign = function() {
    return this._align;
}

s.Action.prototype.setAlign = function(align) {
    this._align = align;
    return this;
}

s.Action.prototype.check = function() {
    return this._userScriptCheck();
}

s.Action.prototype.choose = function() {
    return this._userScriptChoose();
}
/* twine-user-script #5: "0050-Node.js" */
s.nodes = new Map(); // maps SugarCube `Passage` objects to associated
                     // `Node` objects

s.getNode = function(psgTitle) {
    /*
    Returns the Node object associate with the passage titled,
    `psgTitle`.
    */
    return s.nodes.get(Story.get(psgTitle));
}

s.specialPsgs = [
    'PassageDone', 'PassageFooter', 'PassageHeader', 'PassageReady',
    'StoryAuthor', 'StoryBanner', 'StoryCaption', 'StoryInit',
    'StoryInterface', 'StoryMenu', 'StorySettings', 'StoryShare',
    'StorySubtitle', 'StoryTitle'
];

s.Node = function(psgTitle, subCount, func) {
    /*
    A `Node` object is like a wrapper around a passage. It contains the
    passage which holds the narrative description of the situation, as
    well as a list of possible actions for the reader to choose from.

    Structurally, a node is a list of actions with a passage for the
    narrative description, and some additional methods. As such, it is
    implemented as a subclass of `List`.

    The associated passage may have slots available for dynamically
    generated text substitutions. The node object has properties and
    methods for managing this. The `subCount` property should match the
    number of available text substitutions. It is there for a redundancy
    check to prevent the error of sending the wrong number of text
    substitutions when loading a node.

    Node objects, and their associated Action and Outcome objects,
    should be built on `s` so they are not stored in the player's local
    storage. As such, they will not be saved from session to session, so
    they should not be changed dynamically during gameplay.

    @param {String} psgTitle - The title of the associated passage.
    @param {Integer} subCount - The number of expected text
    substitutions. Defaults to 0.
    @param {Function} func (optional) - The function to call when the
    node is loaded. It runs immediately before the loading of the
    passage associated with the calling node. By default, it does
    nothing.

    @property passage - The SugarCube `Passage` object whose title is
    `psgTitle`
    */
    s.List.call(this);
    if (!Story.has(psgTitle)) {
        throw new Error(
            'Node():\n' +
            'there is no passage titled "' + psgTitle + '"'
        );
    }
    if (s.specialPsgs.indexOf(psgTitle) >= 0) {
        throw new Error(
            'Node():\n' +
            'cannot assign a special passage other than `Start` to a node'
        );
    }
    var psg = Story.get(psgTitle);
    if (s.nodes.has(psg)) {
        throw new Error(
            'Node():\n' +
            'the passage "' + psgTitle + '" already belongs to a node'
        );
    }
    this._passage = psg;
    s.nodes.set(psg, this);
    this._subCount = subCount || 0;
    this._userScript = func || function() {
        return;
    }
    return this;
};

s.Node.prototype = Object.create(s.List.prototype);

Object.defineProperty(s.Node.prototype, 'constructor', {
    value: s.Node,
    enumerable: false,
    writable: true
});

s.Node.prototype._verify = function(obj) {
    /*
    @override

    Members of a `Node` must be actions that are registered with the
    factory.
    */
    return (obj instanceof s.Action);
}

s.Node.prototype.getPassage = function() {
    return this._passage;
}

s.Node.prototype.getSubCount = function() {
    return this._subCount;
}

s.Node.prototype.onLoad = function() {
    return this._userScript();
}
/* twine-user-script #6: "0060-Parser.js" */
v.static = {};

Object.defineProperty(window, "st", {
    get: function() {
        return State.variables.static;
    }
});

s.loadVars = function(time) {
    // Replaces `v` with a copy of `State.variables` from the moment
    // with index `time`. Does not touch `v.static`.
    //
    // @param {Integer} time - A nonpositive integer representing the
    // time from which to take the variable data. A value of 0 denotes
    // the present.
    var oldVars = State.peek(-time).variables;
    Object.keys(v).forEach(function(pn) {
        if (pn !== 'static') {
            delete v[pn];
        }
    });
    Object.keys(oldVars).forEach(function(pn) {
        if (pn !== 'static') {
            v[pn] = clone(oldVars[pn]);
        }
    });
    return;
}

/*
A Parser object manages the conversion of the given passage text to the
actual passage text used by SugarCube to display information.

There is one instance (`st.parser`, see Page.js), built on
State.variables, so its state can be stored in SugarCube's history.
(This is needed, because the parser tracks dynamically generated text
substitutions.) The class must therefore be made compatible with
SugarCube by having `clone()` and `toJSON()` methods, and no recursive
objects or object sharing. To achieve this, we also require it to have a
constructor with no arguments and to have all its properties be SC
supported types.

There are various methods for processing different kinds of markup. The
method, `procMarkup()`, runs them all in the appropriate order. Through
`Config.passages.onProcess`, we instruct SugarCube to apply
`procMarkup()` to passage text whenever a passage is rendered.
*/

s.Parser = function() {
    this._textSubMap = new Map(); // Maps passage titles to arrays of
                                  // text subs. A text sub can be a
                                  // simple string or a functions
                                  // returning a string.
    return this;    
};

s.Parser.prototype._init = function(obj) {
    /* Needed for SugarCube compatibility. */
    Object.keys(obj).forEach(function (pn) {
        this[pn] = clone(obj[pn]);
    }, this);
    return this;
};

s.Parser.prototype.clone = function () {
    /* Needed for SugarCube compatibility. */
    return (new s.Parser())._init(this);
};

s.Parser.prototype.toJSON = function () {
    /* Needed for SugarCube compatibility. */
    var newPC = {};
    Object.keys(this).forEach(function (pn) {
        newPC[pn] = clone(this[pn]);
    }, this);
    return JSON.reviveWrapper(
        '(new s.Parser())._init($ReviveData$)', newPC
    );
};

s.Parser.prototype.getSubs = function(psgTitle) {
    return this._textSubMap.get(psgTitle);
}

s.Parser.prototype.setSubs = function(psgTitle, subArray) {
    /*
    Adds `psgTitle` key to `_textSubMap` with value `subArray`. Throws
    an error if `psgTitle` doesn't correspond to a node, length of
    `subArray` doesn't match the sub count of the node, or `subArray` is
    not an array of strings or functions. Returns the calling Parser
    object.
    */
    var node = s.getNode(psgTitle);
    if (node === undefined) {
        throw new Error(
            'Parser.setSubs():\n' +
            '"' + psgTitle + '" does not correspond to a node.'
        );
    }
    if (node.getSubCount() !== subArray.length) {
        throw new Error(
            'Parser.setSubs():\n' +
            'unexpected number of text substitutions'
        );
    }
    if (!subArray.every(function(element) {
        return (typeof(element) === 'string' ||
                typeof(element) === 'function');
    })) {
        throw new Error(
            'Parser.setSubs():\n' +
            'text substitutions must be strings or' +
            'functions that return strings'
        );
    }
    this._textSubMap.set(psgTitle, subArray);
    return this;
}

s.Parser.prototype.insertTextSubs = function(psgTitle, text) {
    /*
    Fetches the array of text substitutions corresponding to `psgTitle`,
    or `[]` if there is no such array, then replaces instances of
    `{<number>}` in the given text with corresponding elements from that
    array.

    Does nothing if the node associated with `psgTitle` has a sub count
    of 0. Throws an error if the sub count doesn't match the length of
    the substitution array, if any index is out of bounds, if any index
    is repeated, or if there are not enough indices. Returns the
    processed text.

    @param {String} psgTitle - The title of the passage being processed.
    This passage title must correspond to a node. Passing a title that
    does not correspond to a node could have unexpected behavior.
    @param {String} text - The text to process.
    */
    var subArray = (this.getSubs(psgTitle) || []);
    subArray = subArray.map(function(element) {
        if (typeof(element) === 'function') {
            return element();
        } else {
            return element;
        }
    });

    var psg = Story.get(psgTitle);
    var node = s.nodes.get(psg);
    var subCount = node.getSubCount();
    if (subCount === 0) {
        return text;
    }

    var psgId = psg.domId;
    var subsFound = new Set();
    var regex = /\{(\d+?)\}/;
    var processedText = text;
    var result, index;
    while (true) {
        result = regex.exec(processedText);
        if (result === null) {
            if (subsFound.size < subCount) {
                throw new Error(
                    'too few text substitutions in passage, "' +
                    psgTitle + '"'
                );
            }
            return processedText;
        }
        index = parseInt(result[1], 10);
        if (index >= subCount) {
            throw new Error(
                'text substitution index out of range in passage, "' +
                psgTitle + '"'
            );
        }
        if (subsFound.has(index)) {
            throw new Error(
                'duplicate text substitution index in passage, "' +
                passage.title + '"'
            );
        }
        subsFound.add(index);
        processedText = (
            processedText.slice(0, result.index) +
            subArray[index] +
            processedText.slice(result.index + result[0].length)
        );
    }
}

s.Parser.prototype.showDetails = function(description, id) {
    /*
    Inserts the given description into the element with the given id and
    clears all other elements with class `.description`. If the element
    with the given id already contains the given description, the
    function simply clears it.

    @param {String} description - the description to insert
    @param {String} id - the id of the containing element
    */
    var text = jQuery("#" + id).html();     // store the current content
                                            // for comparison

    jQuery(".description").empty()          // clear all elements

    jQuery("#" + id).wiki(description);     // insert the description

    if (text === jQuery("#" + id).html()) { // empty content if already
        jQuery("#" + id).empty();           // present
    }

    return;
}

s.Parser.prototype.procDetailMarkup = function(psgTitle, text) {
    /*
    Replaces instances of `{<link text>|id}` in text with links that
    reveal a description. The description is found in a corresponding
    instance of `{?id|description}` which is replaced by a div element
    into which the description appears. The html id of the div element
    is determined by both the id in the markup and the given `psgTitle`.
    The appearance of the description is controlled by the method
    `Parser.showDetails()`.

    The link text cannot begin with a `?` and cannot contain a `|`. The
    id must contain only letters, numbers, and `_`, and must begin with
    a letter.

    @param {String} psgTitle - The title of the passage being processed.
    @param {String} text - The text of the passage being processed.
    */
    var psg = Story.get(psgTitle);
    var psgId = psg.domId;

    var linkRegex = /\{(.+?)\|([a-zA-Z][0-9a-zA-Z_]*?)\}/;

    var processedText = text;

    var cut = [0,0,0,0];         // indices at which to cut the given
                                 // text

    var part = ['','','','','']; // substrings to concatenate in order
                                 // to build the new text

    var j;                       // temporary storage, used in building
                                 // `cut`

    var linkResult, linkText, linkId, elementId;
    var descRegex, descResult, descText, descLoc;
    while (true) {
        linkResult = linkRegex.exec(processedText);

        if (linkResult === null) {
            return processedText.replace(
                /\{\?([a-zA-Z][0-9a-zA-Z_]*?)\|(.+?)\}/g, ''
            );
        }
        
        linkId = linkResult[2];
        descRegex = new RegExp(
            '\\{\\?' + linkId + '\\|(.+?)\\}'
        );
        descResult = descRegex.exec(processedText);

        if (descResult === null) {
            throw new Error(
                'link markup without description markup in passage, "' +
                psgTitle + '"'
            );
        }

        linkText = linkResult[1];
        descText = descResult[1];
        elementId = psgId + '-examine-' + linkId;

        j = linkResult.index < descResult.index ? 0 : 2;
        cut[j] = linkResult.index;
        cut[j+1] = linkResult.index + linkResult[0].length;
        cut[2-j] = descResult.index;
        cut[3-j] = descResult.index + descResult[0].length;

        part[0] = processedText.slice(0, cut[0]);
        part[2] = processedText.slice(cut[1], cut[2]);
        part[4] = processedText.slice(cut[3])

        part[j+1] = (
            '<<link "' + linkText + '">>' +
                '<<run st.parser.showDetails(' + 
                    '"' + descText + '", "' + elementId + '"' +
                ')>>' +
            '<</link>>'
        );

        part[3-j] = (
            '<div id="' + elementId + '" class="description">' +
            '</div>'
        );

        processedText = part.join('');
    }
}

s.Parser.prototype.addContainers = function(psgTitle, text) {
    /*
    Wraps the given text in a `body` container; adds an `action`
    container for the action links; adds a `next` container in case the
    next node is to be loaded without a passage transition. The html id
    of the containers is determined by `psgTitle`.

    @param {String} psgTitle - The title of the passage being processed.
    This passage title must correspond to a node. Passing a title that
    does not correspond to a node could have unexpected behavior.
    @param {String} text - The text to process.
    */
    var psg = Story.get(psgTitle);
    return (
        '<div id="' + psg.domId + '-body">\n\n' +
            text + '\n\n' +
        '</div>\n\n' + 
        '<div id="' + psg.domId + '-actions"></div>\n\n' +
        '<div id="' + psg.domId + '-next"></div>'
    );

}

s.Parser.prototype.removeBreaks = function(text) {
    /*
    Removes line breaks from the given text.
    */
    var processedText = text.replace(/\r/g, '');
    processedText = processedText.replace(/^\n+|\n+$/g, '');
    processedText = processedText.replace(/\n+/g, ' ');
    return processedText;
}

s.Parser.prototype.procAllMarkup = function(psgTitle, text, time) {
    /*
    Processes the special node markup in the given passage (inserts text
    subs, processes the detail markup, adds the containers, and removes
    breaks. Does nothing if the given passage is not associated with a
    node. Returns the processed text.

    The optional `time` parameter is used to set the moment in SC's
    history from which to draw the values of variables. It allows for
    the use of variables in passage content. It should be a nonpositive
    integer. A value of 0 denotes the current moment. Defaults to zero.

    @param {String} psgTitle - The title of the passage being processed.
    @param {String} text - The text of the passage being processed.
    @param {Integer} time - (optional) A nonpositive integer that
    defaults to zero. Sets the moment in history to use when parsing.
    */
    var node = s.nodes.get(Story.get(psgTitle));
    if (node === undefined) {
        return text;
    }

    time = time || 0;
    if (time < 0) {
        s.loadVars(time);
    }

    var processedText = text;
    processedText = this.insertTextSubs(psgTitle, processedText);
    processedText = this.procDetailMarkup(psgTitle, processedText);
    processedText = this.addContainers(psgTitle, processedText);
    processedText = this.removeBreaks(processedText);

    if (time < 0) {
        s.loadVars(0);
    }

    return processedText;
}
/* twine-user-script #7: "0070-Page.js" */
st.parser = new s.Parser();

/*
A `Page` object represents the content which is displayed on the screen.
Traditionally in SugarCube, this is just a passage. But with the node
system, multiple passages can be displayed at a time, in order. The
first passage is the main one and the one which SugarCube regards as
being displayed. The other passages are displayed inside the first
passage.

There is one instance (`st.page`, see Global.js), built on
State.variables, so its state can be stored in SugarCube's history.
(This allows SugarCube to rebuild the page upon a browser refresh or
upon loading a save file.) The class must therefore be made compatible
with SugarCube by having `clone()` and `toJSON()` methods, and no
recursive objects or object sharing. To achieve this, we also require it
to have a constructor with no arguments and to have all its properties
be SC supported types.
*/

s.Page = function() {
    this._embeddedPsgs = [];  // list of embedded passage titles; does
                              // not include the first (main) passage
    this._noBreakFlags = [];  // list of nobreak flags (true if passage
                              // was embedded without a scene break)
    this._continuous = false; // set true to have passages embed by
                              // default
    return this;    
};

s.Page.prototype._init = function(obj) {
    /* Needed for SugarCube compatibility. */
    Object.keys(obj).forEach(function (pn) {
        this[pn] = clone(obj[pn]);
    }, this);
    return this;
};

s.Page.prototype.clone = function () {
    /* Needed for SugarCube compatibility. */
    return (new s.Page())._init(this);
};

s.Page.prototype.toJSON = function () {
    /* Needed for SugarCube compatibility. */
    var newPC = {};
    Object.keys(this).forEach(function (pn) {
        newPC[pn] = clone(this[pn]);
    }, this);
    return JSON.reviveWrapper(
        '(new s.Page())._init($ReviveData$)', newPC
    );
};

s.Page.prototype.length = function() {
    return this._embeddedPsgs.length;
}

s.Page.prototype.getPsg = function(index) {
    return this._embeddedPsgs[index];
}

s.Page.prototype.getFlag = function(index) {
    return this._noBreakFlags[index];
}

s.Page.prototype.isContinuous = function() {
    return this._continuous;
}

s.Page.prototype.setContinuous = function(val) {
    this._continuous = val;
    return this;
}

s.Page.prototype.insertActions = function(psg) {
    /*
    For each action in the node corresponding to the given SC passage
    object, this function checks if the action should be displayed. If
    it passes the check, it adds a link for the corresponding action.
    Does nothing if the incoming passage does not correspond to a node.
    */
    var node = s.nodes.get(psg);
    if (node === undefined) {
        return;
    }

    var psgTitle = psg.title;
    var psgId = psg.domId;
    var action;
    for (var i = 0; i < node.length(); i++) {
        action = node.get(i);
        if (action.check()) {
            $('#' + psgId + '-actions').wiki(
                '<p style="text-align:' + action.getAlign() + '">' +
                    '<<link "' + action.getText() + '">>'+
                        '<<run s.nodes.get(Story.get("' + psgTitle + '"))' +
                        '.get(' + i + ').choose().carryOut()>>' +
                    '<</link>>' +
                '</p>'
            );
        }
    }
    return this;
}

s.Page.prototype.innerPsg = function() {
    /*
    Returns the innermost passage on the page as a SC Passage object.
    */
    var psg;
    if (this._embeddedPsgs.length === 0) {
        psg = Story.get(passage());
    } else {
        var title = this._embeddedPsgs[this._embeddedPsgs.length - 1];
        psg = Story.get(title);
    }
    return psg;
}

s.Page.prototype.scrollToLast = function() {
    /*
    Scrolls to put the innermost passage at the top.
    */
    $('html, body').animate({
        scrollTop: $('#' + this.innerPsg().domId + '-body').position().top
    }, 0);
    return this;
}

s.Page.prototype.insertPsgText = function(psg, shellPsg, time, nobreak) {
    /*
    Inserts the given passage into the given shell passage, preceded by
    a scene break ("****"). The scene break is omitted is `nobreak` is
    true.

    The optional `time` parameter is used to set the moment in SC's
    history from which to draw the values of variables. It allows for
    the use of variables in passage content. It should be a nonpositive
    integer. A value of 0 denotes the current moment. Defaults to zero.

    @param {<<SC Passage object>>} psg - The passage to embed.
    @param {<<SC Passage object>>} shellPsg - The passage into which to
    embed.
    @param {Integer} time - (optional) A nonpositive integer that
    defaults to zero. Sets the moment in history to use when parsing.
    @param {Boolean} nobreak - (optional) Defaults to false. Set to true
    to omit the scene break marker.
    */
    time = time || 0;
    if (time < 0) {
        s.loadVars(time);
    }

    var sceneBreak = nobreak ? '' : '<p style="text-align:center">****</p>';
    $('#' + shellPsg.domId + '-next').wiki(
        sceneBreak +
        st.parser.procAllMarkup(psg.title, psg.text)
    );

    if (time < 0) {
        s.loadVars(0);
    }

    return this;
}

s.Page.prototype.embedPsg = function(node, time, nobreak) {
    /*
    Removes the current actions from the page, inserts the given node
    and its actions into the bottom of the page, scrolls to put the new
    content at the top, appends the page's list of embedded passages,
    and adds a new moment to SC's history. The embedded passage is
    preceded by a scene break ("****") unless `nobreak` is true.

    The time parameter is a nonpositive integer that defaults to zero
    and sets the moment in history to use when parsing. See
    `Page.insertPsgText` for details.
    */
    var nodePsg = node.getPassage();
    if (nodePsg.title === passage() ||
        this._embeddedPsgs.indexOf(nodePsg.title) >= 0) {
        throw new Error(
            'Page.load():\n' +
            'cannot embed a passage in itself'
        );
    }

    var latestPsg = this.innerPsg();
    $('#' + latestPsg.domId + '-actions').empty();
    this.insertPsgText(nodePsg, latestPsg, time, nobreak);
    this.insertActions(nodePsg);
    this._embeddedPsgs.push(nodePsg.title);
    this._noBreakFlags.push(nobreak);
    this.scrollToLast();
    State.create(State.passage);
    Save.autosave.save();
    return this;
}

s.Page.prototype.load = function(node, embed, nobreak) {
    /*
    Runs the given node's `onLoad` function, then renders the node's
    passage. If the optional parameter `embed` is true, then rather than
    rendering the passage, the passage's contents are appended to the
    end of the last embedded passage, the page is scrolled to put the
    new passage content at the top, and a new moment is added to SC's
    history. The appended content is preceded by a scene break ("****"),
    unless the optional `nobreak` parameter is true.
    */
    if (embed === undefined) {
        embed = this._continuous;
    }
    node.onLoad();
    var nodePsg = node.getPassage();
    if (embed) {
        this.embedPsg(node, 0, nobreak);
        return this;
    } else {
        this._embeddedPsgs = [];
        this._noBreakFlags = [];
        Engine.play(nodePsg.title);
        return this;
    }
}
/* twine-user-script #8: "8000-Global.js" */
/*
Global objects scattered throughout code:
----
from Node.js:
    s.nodes : Map(<<SC Passage obj>> : Node)
    s.getNode(psgTitle: String): Node
    s.specialPassages : String[]
from Parser.js:
    st.parser : Parser
*/

Config.passages.nobr = true; // sets all passages to `nobr`

window.onerror = function(msg, url, linenumber) {
    /*
    Ensures that errors appear in a pop-up for greater visibility. Works
    in Firefox, but doesn't seem to work in Safari. Be sure to do
    testing in Firefox.
    */
    alert(
        'Error message: ' + msg + '\n' +
        'URL: ' + url + '\n' +
        'Line Number: ' + linenumber
    );
    return true;
}

s.makeLink = function(startPsgTitle, text, endPsgTitle,
                      func, embed, nobreak) {
    /*
    Creates a new Outcome that runs `func`, then loads the node
    associated with `endPsgTitle`. Then adds that Outcome to a new
    Action with the given `text` as its link text. Then adds that Action
    to the associated with `startPsgTitle`. The target node is loaded
    with the optional `embed` and `nobreak` parameters.

    If there are no nodes associated with the given passage titles, they
    will be created.

    Returns the newly created action.
    */
    var startNode = s.nodes.get(Story.get(startPsgTitle));
    if (startNode === undefined) {
        startNode = new s.Node(startPsgTitle);
    }

    var targetNode = s.nodes.get(Story.get(endPsgTitle));
    if (targetNode === undefined) {
        targetNode = new s.Node(endPsgTitle);
    }

    var outcome;
    if (func === undefined) {
        outcome = new s.Outcome(function() {
            st.page.load(targetNode);
        });
    } else {
        outcome = new s.Outcome(function() {
            func();
            st.page.load(targetNode, embed, nobreak);
        });
    }

    var action = new s.Action(text).push(outcome);
    startNode.push(action);
    return action;
}

s.none = function() { return; } // for convenience when passing an empty
                                // function as a parameter

st.page = new s.Page();

Config.passages.onProcess = function(p) {
    /*
    Rewinds variables to a previous moment to account for embedded
    passages. Variables will be restored on `:passagedisplay`. Then
    processes the node markup.
    */
    s.loadVars(-st.page.length());
    var processedText = st.parser.procAllMarkup(
        p.title, p.text
    );
    return processedText;
};

s.onPsgDisplay = function(ev) {
    /*
    Triggered by the `:passagedisplay` event. Rebuilds the current page.
    */
    s.loadVars(0); // resets variables to current time

    var currentPsg = ev.passage;
    var nextPsg, time;
    for (var i = 0; i < st.page.length(); i++) {
        /*
        Re-inserts embedded passage text one at a time.
        */
        nextPsg = Story.get(st.page.getPsg(i));
        time = i - (st.page.length() - 1)
        st.page.insertPsgText(
            nextPsg, currentPsg, time, st.page.getFlag(i)
        );
        currentPsg = nextPsg;
    }

    st.page.insertActions(st.page.innerPsg());
    st.page.scrollToLast();
    return;
}

$(document).on(':passagedisplay', s.onPsgDisplay);

Config.saves.autosave = true;

Config.saves.isAllowed = function () {
    return (passage() !== 'Start' || st.page.length() > 0);
};

$(window).bind('beforeunload',function(){
   Engine.restart();
});
/* twine-user-script #9: "9000-Main.js" */
st.page.setContinuous(true);

s.makeLink(
    'Start',
    '<<if Save.autosave.has()>>restart<<else>>begin<</if>>',
    'intro',
    function() {
        return Save.autosave.delete();
    },
    true, true
).setAlign('center');
s.getNode('Start').push((new s.Action(
    'resume',
    function() {
        return Save.autosave.has();
    }
)).setAlign('center').push(new s.Outcome(function() {
    Save.autosave.load();
})));

s.makeLink('intro', 'continue', 'RNG warning');
s.makeLink('RNG warning', 'got it', 'who you are');

// s.bedroom = (new s.Node('bedroom', 2))
// v.parser.setSubs('bedroom', [
//     function() {
//         if (v.pounding) {
//             return 'You can hear the pounding on the front door coming from ' +
//                    'that direction. ';
//         } else if (v.crowbar) {
//             return 'Outside the bedroom, ' +
//                    (v.knowledge.has('policeAtDoor') ?
//                         'the police are' : 'someone is') +
//                    ' breaking into the house with a crowbar. ';
//         } else {
//             return '';
//         }
//     },
//     function() {
//         return (
//             v.containedIn.get('knife') == 'bedroom' ?
//             "What looks like a heavy-duty {chef's knife|D} is sticking out of"
//                 + 'his chest.' :
//             ''
//         );
//     }
// ]);
s.makeLink('who you are', 'take a look around', 'bedroom', s.none, false);

s.getNode('bedroom').push((new s.Action(
    'take the knife',
    function() {
        return (v.containedIn.get('knife') === 'bedroom');
    }
)).push(new s.Outcome(function() {
    v.containedIn.delete('knife');
    v.inventory.add('knife');
    st.parser.setSubs('Taking knife', [' You may need this for later.']);
    st.page.load(s.takingKnife, true, true);
    return;
})));

s.getNode('bedroom').push((new s.Action(
    'search the body',
    function() {
        return !v.body.searched;
    }
)).push(new s.Outcome(function() {
    v.body.searched = true;
    v.pounding = false;
    st.parser.setSubs('Cops bust in', [
        '',

        'As you bend down to take a closer look at the body, the bedroom ' +
        'door bursts open. ' 
    ]);
    st.page.load(s.copsBustIn, true);
    return;
})));



s.copsBustIn = new s.Node('Cops bust in', 2, function() {
    v.detective.discovered = true;
    return;
});



s.takingKnife = new s.Node('Taking knife', 1);

s.bedroom = s.getNode('bedroom')
for (var i = 0; i < s.bedroom.length(); i++) {
    s.takingKnife.push(s.bedroom.get(i));
}

s.makeLink('Cops bust in', 'continue', 'Next', function() {
    v.inventory.delete('knife');
});
/* twine-user-script #10: "Story JavaScript" */


:: StorySubtitle
Story Subtitle


:: StoryAuthor
Story Author


:: StoryDisplayTitle
Story Display Title


:: StoryBanner
Story Banner


:: StoryCaption
Story Caption


:: StoryMenu
<<link 'menu item 1'>><</link>>
<<link 'menu item 2'>><</link>>


:: StoryInit
<<set $pounding = true>>
<<set $crowbar = false>>
<<set $knowledge = new Set()>>
<<set $containedIn = new Map()>>
<<run $containedIn.set("knife", "bedroom")>>
<<set $body = {
    searched: false
}>>
<<set $detective = {
    discovered: false
}>>
<<set $inventory = new Set()>>


:: Start
<div style='text-align:center'>
    <h1><<= Story.title>></h1>
    by<br>
    <<= Story.get('StoryAuthor').text>><br>
    <br>
    <br>
    <br>
</div>


:: intro
<p>It started with one shot of whiskey. Of course, most nights started with one shot of whiskey. Then one became two and two became more. Before long, you were making a fool of yourself. At least you assume you were. You can't remember.</p>

<p>That was last night. This morning, you wake up alone on a strange bed in a house you've never seen before. From the trash and bottles lying around, this had to be the scene of some after-party. But where is everyone? And what is that smell? It's then you realize your clothes are covered in blood.</p>

<p>When you get out of the bed, you see it. The body. A man lying on his back, dead, with a knife sticking out of his chest. Before you can do or think anything, someone starts pounding on the front door. Is it the police? Is it the murderer? Are //you// the murderer?</p>


:: RNG warning
<p>In this story, your choices can have random consequences. The chances of the various outcomes are affected by your character's traits. You can read about those traits on the Character Sheet. The Character Sheet also shows what you are carrying, what you have learned, and any injuries you may have suffered.</p>


:: who you are
<p>Scott Allen Brady. Scotty, to your friends. That's your name. You have to remind yourself, just to make sure you haven't forgotten //everything//. The last thing you remember is leaving work. You'd finished packing the motherboards into their shipping crates. Then you clocked out and left the plant. You were still wearing your Hewlett-Packard shirt when you got in your truck. You met some friends at the bar. Then...</p>

<p>Nothing. You can't remember. Now here you are, in some surreal nightmare, looking at a dead guy. The pounding on the door makes it hard to concentrate.</p>


:: bedroom
<p>You are in what has to be the master bedroom. You reek of alcohol, your mouth is dry and tastes like vomit, and your head is throbbing. There's blood on your clothes, in your hair, and on your face and hands. You've had better days.</p>

<p>You're wearing a white T-shirt with the Seattle Seahawks logo on the front. But you can hardly see the logo under all the blood. Your jeans are also caked with dried blood.</p>

<p>On your left, the {bedroom door|A} is closed. <<if $pounding>>You can hear the pounding on the front door coming from that direction. <<elseif $crowbar>>Outside the bedroom, <<if $knowledge.has("policeAtDoor")>>the police are<<else>>someone is<</if>> breaking into the house with a crowbar. <</if>>To your right, the {door|B} to the adjoining bathroom is ajar. On the floor is a {dead man|C}, lying on his back in a pool of blood. <<if $containedIn.get("knife") == "bedroom">>What looks like a heavy-duty {chef's knife|D} is sticking out of his chest.<</if>></p>

{?A|<p>The bedroom door is white, like the walls of the room. Blood is spattered on the left side near the door handle.</p>}

{?B|<p>The bathroom door is made of cheap plywood and won't even close all the way.</p>}

{?C|<p>You've never seen the dead man before, as far as you can remember. He must be in his mid-thirties.</p>}

{?D|<p>The murder weapon looks like the kind of knife they have hanging on the wall in a restaurant kitchen--the kind they use to cut meat or chop big vegetables. It has a wide blade and is about a foot long.</p>}


:: Cops bust in
<p>{0}</p>

<p>{1}Three men rush in. "Get down on the ground!" one shouts. <<if $inventory.has("knife")>>"He's got a knife!" yells another.<</if>> They all have their guns trained on you. The bald man in the center looks like a police {detective|A}. The other two are uniformed cops.</p>

{?A|The detective doesn't move. He doesn't blink. He just stands there scowling, waiting for you to make a move.}


:: Taking knife
<p>You take the knife and carefully slide it under your belt.{0}</p>


:: Next
To be continued.


