:: StoryTitle
Story Title


:: StoryData
{
	"ifid": "5406BF44-CF93-41CF-9DED-9824A52E2F82",
	"format": "SugarCube",
	"format-version": "2.31.1",
	"start": "Start",
	"zoom": 1
}


:: Story Stylesheet [stylesheet]
/* twine-user-stylesheet #1: "main.css" */
html {
    font: 100% Georgia, serif;
}
body {
    color: white;
    background-color: black;
}
a {
    cursor: pointer;
    color: #68d;
    text-decoration: none;
    font-weight: bold;
    transition-duration: 200ms;
}
.description {
    /* Detailed description information revealed when clicking a noun. */
    color: yellow;
}
.headings {
    /* Headings in help page. */
    color: lime;
}
.sticky{
    /* Makes the header stick to the top of the screen. */
    position: sticky;
    position: -webkit-sticky;
    top: 0;
    left: 0;
    width: 100%;
    z-index: 49;
    background-color: black;
}
#story {
    /* Removes the top margin, so the header sticks seamlessly. Line breaks should be added manually at the top of the header and any passage with a `no-header` tag. This is handled automatically by the `onProcess` function in `rendering.js`. */
    margin-top: 0px;
}
#header button {
    color: #68d;
    background-color: black;
}
/* twine-user-stylesheet #2: "Story Stylesheet" */


:: Story JavaScript [script]
/* twine-user-script #1: "0010-standard.js" */
/*Establishes shorthand aliases for commonly used namespaces, and sets
other basic properties.

Attributes:
    s (obj): Alias for `setup`.
    ss (obj): Alias for `settings`.
    v (obj): Alias for `State.variables`.
    t (obj): Alias for `State.temporary`.
    v.static (obj): We will occasionally make temporary journeys in time
         via SC's history. This namespace is for variables that should be
         unaffected by those journeys.
    st (obj): Alias for `v.static`.
    Config.passages.nobr (bool): Set to true, which applies `nobr` to
        all SC passages.
    Config.saves.autosave (bool): Set to true, which turns on SC's
        autosave feature.
    s.autosave.sufficient (array of functions): Array of Boolean-valued
        functions giving sufficient conditions to allow autosaving.
    s.autosave.necessary (array of functions): Array of Boolean-valued
        functions giving necessary conditions to allow autosaving.

*/

Object.defineProperty(window, "s", {
    get: function() {
        return setup;
    }
});

Object.defineProperty(window, "ss", {
    get: function() {
        return settings;
    }
});

Object.defineProperty(window, "v", {
    get: function() {
        return State.variables;
    }
});

Object.defineProperty(window, "t", {
    get: function() {
        return State.temporary;
    }
});

v.static = {}; 

Object.defineProperty(window, "st", {
    get: function() {
        return State.variables.static;
    }
});

s.loadVars = function(time) {
    /*Replaces `v` with a copy of `State.variables` from the moment with
    index `time`. Does not touch `v.static`.

    Note:
        This function originally required `time` to be a nonpositive
        integer. For compatibility with code that may use the original
        version of this function, a negative value of `time` is still
        accepted, but immediately replaced by its absolute value.

    Args:
        time (int): A nonnegative integer representing the time from
        which to take the variable data. A value of 0 denotes the
        present. A value of n > 0 means to go back n moments in SC's
        history.
    */
    time = (time < 0) ? -time : time

    var oldVars = State.peek(time).variables;
    Object.keys(v).forEach(function(pn) {
        if (pn !== 'static') {
            delete v[pn];
        }
    });
    Object.keys(oldVars).forEach(function(pn) {
        if (pn !== 'static') {
            v[pn] = clone(oldVars[pn]);
        }
    });
    return;
}

Config.passages.nobr = true;

window.onerror = function(msg, url, linenumber) {
    /*Ensures that errors appear in a pop-up for greater visibility.
    Works in Firefox, but doesn't seem to work in Safari. Be sure to do
    testing in Firefox.

    Args:
        msg (str): Error message.
        url (str): Error URL.
        linenumber (int): Error line number.

    Returns:
        bool: Returns `true`.
    */
    alert(
        'Error message: ' + msg + '\n' +
        'URL: ' + url + '\n' +
        'Line Number: ' + linenumber
    );
    return true;
}

Config.saves.autosave = true;

s.autosave = {
    sufficient: [],
    necessary: []
}

Config.saves.isAllowed = function () {
    /*Uses `s.autosave` to determine if the autosave is allowed. Passing
    any sufficient check allows the save; failing any necessary check
    prevents the save. Otherwise, save is allowed.

    Returns:
        bool: `true` if the the save is allowed, `false` otherwise.
    */
    var i;
    for (i = 0; i < s.autosave.sufficient.length; i++) {
        if (!s.autosave.sufficient[i]()) {
            continue;
        }
        return true;
    }
    for (i = 0; i < s.autosave.necessary.length; i++) {
        if (s.autosave.necessary[i]()) {
            continue;
        }
        return false;
    }
    return true;
};

s.autosave.necessary.push(function() {
    /*Prevents autosave at the 'Start' passage.

    Returns:
        bool: `true` if current passage title is not `Start`.
    */
    return (passage() !== 'Start');
});
/* twine-user-script #2: "0020-Outcome.js" */
/*Uses: standard.

Builds the `Outcome` class.

*/

s.Outcome = function(func) {
    /*Represents one possible result of a player action.

    Args:
        func (func, optional): Assigned to the `_userScript`
            attribute. Defaults to a function that does nothing.

    Attributes:
        _userScript (func): The function to call when the outcome is
            carried out. Should take no parameters.

    */
    
    this._userScript = func;
    return this;
}

s.Outcome.prototype.carryOut = function() {
    /*Does nothing if `this._userScript` is `null` or `undefined`,
    otherwise executes `this._userScript`.

    Returns:
        Returns the same value as `this._userScript`.
    */
    if (this._userScript == null) {
        return;
    } else {
        return this._userScript();    
    }
}
/* twine-user-script #3: "0030-List.js" */
/*Uses: standard

Creates the `List` class.

*/

s.List = function(fixedEnd) {
    /*A wrapper around an array.

    The `List` class offers methods for controlling manipulation of and
    access to elements in the embedded array.

    Args:
        fixedEnd (int or bool, optional): If an integer, assigned to
            `_fixedEnd` attribute. If a boolean value, converted to 0 or
            1 before being assigned. Defaults to 0.

    Attributes:
        _array (arr): The embedded array.
        _fixedEnd (int): Indicates how many elements at the end of the
            array to keep fixed in place.

    */

    this._array = [];
    if (fixedEnd === undefined) {
        this._fixedEnd = 0;
    } else if (typeof fixedEnd === 'boolean') {
        this._fixedEnd = fixedEnd ? 1 : 0;
    } else {
        this._fixedEnd = fixedEnd;
    }
    return this;
}

s.List.prototype._verify = function(obj) {
    /*Checks if `obj` qualifies to be in the list. Should be overridden
    by subclasses.

    Args:
        obj (obj): The object to test.

    Returns:
        bool: `true` if the object qualifies, `false` otherwise.
    */
    return true;
}

s.List.prototype.insert = function(index, obj) {
    /*If the object passes the `_verify` test, inserts it at index. (E.g.,
    an index of 0 inserts it at the beginning, and index equal to the
    length of _array inserts it at the end.)

    If _fixedEnd is positive and you try to insert past a fixed element,
    will insert just before the first fixed element instead.

    Args:
        index (int): The index at which to insert.
        obj (obj): The object to insert.

    Returns:
        List: The calling instance.

    Raises:
        Error: If `obj` fails the `_verify` test.
    */
    if (this._verify(obj)) {
        var end = Math.max(0,this._array.length - this._fixedEnd);
        index = Math.min(index, end);
        this._array.splice(index, 0, obj);
    } else {
        throw new Error(
            'List.insert():\n' +
            'object does not qualify for list'
        );
    }
    return this;
}

s.List.prototype.push = function() {
    /*Takes any number of objects as parameters and passes them, in
    order, to the `insert` method, inserting each one at the end of the
    embedded array.

    Args:
        arguments (array): The objects to insert, in order, at the end
        of the embedded array.

    Returns:
        List: The calling instance.
    */
    if (arguments.length > 0) {
        var args = Array.prototype.slice.call(arguments);
        var arg = args.shift();
        this.insert(this._array.length, arg);
        this.push.apply(this, args);
    }
    return this;
}

s.List.prototype.delete = function(index) {
    /*Deletes the list element at the given index of the embedded array.

    Args:
        index (int): The index of the element to delete.

    Returns:
        List: The calling instance.

    Raises:
        Error: If `index` is out of range.
    */
    if (index !== parseInt(index, 10) || index < 0 ||
        index >= this._array.length) {
        throw new Error(
            'List.delete():\n' +
            'invalid index'
        );
    }
    this._array.splice(index, 1);
    return this;
}

s.List.prototype.get = function(index) {
    /*Gets an element from the embedded array.

    Args:
        index (int): The index of the element to get.

    Returns:
        obj: The element gotten.
    */
    return this._array[index];
}

s.List.prototype.indexOf = function(obj) {
    /*Finds the given object in the embedded array.

    Args:
        obj (obj): The object to look for.

    Returns:
        int: The index of the object if found; -1 otherwise.
    */
    return this._array.indexOf(obj);
}

s.List.prototype.length = function() {
    /*Gets the length of the embedded array.

    Returns:
        int: The length of the embedded array.
    */
    return this._array.length;
}
/* twine-user-script #4: "0040-Action.js" */
/*Uses: List.

Builds the `Action` class.

*/

s.Action = function(text, checkFunc, chooseFunc) {
    /*A `List` of `Outcome`s representing an action the user may take.

    In a given passage, the reader will choose from a list of actions.
    Each action can be displayed as a link, and when it is selected,
    the story will choose from a list of that action's possible
    outcomes. An `Action` object represents one of these actions.

    Structurally, an action object is a list of outcomes with a display
    text for the link, and some additional methods available. As such,
    it is implemented as a subclass of `List`.

    Args:
        text (str): Assigned to the `_displayText` attribute.
        checkFunc (func or bool, optional): Assigned to the
            `_userScriptCheck` attribute. Defaults to `true`.
        chooseFunc (func, optional): Assigned to the `_userScriptChoose`
            attribute. Defaults to a function that returns the first
            outcome in the list.

    Attributes:
        _array (arr): The embedded array of `Outcome` objects.
        _fixedEnd (int): Indicates how many elements at the end of the
            array to keep fixed in place. Set to 0 by the constructor.
        _displayTest (str): The text to appear in the link.
        _userScriptCheck (func or bool): The function to call when
            checking if the action should be displayed. Should take no
            parameters and return a boolean. If it is a boolean, simply
            returns that boolean.
        _userScriptChoose (func): The function to call when choosing an
            outcome. Should take no parameters and return an outcome
            from the action.
        _align (str): The CSS text-align value for the link associated
            with this action. Defaults to 'left'.

    */

    s.List.call(this);
    this._displayText = text;

    if (checkFunc == null)  {
        this._userScriptCheck = true;
    } else {
        this._userScriptCheck = checkFunc;
    }

    this._userScriptChoose = chooseFunc || function() {
        return this._array[0];
    }
    this._align = 'left';
    return this;
};

s.Action.prototype = Object.create(s.List.prototype);

Object.defineProperty(s.Action.prototype, 'constructor', {
    value: s.Action,
    enumerable: false,
    writable: true
});

s.Action.prototype._verify = function(obj) {
    /*(override) Members of an `Action` must be `Outcome` objects.

    Args:
        obj (obj): The object to test.

    Returns:
        bool: `true` if the object is an `Outcome`, `false` otherwise.
    */
    return (obj instanceof s.Outcome);
}

s.Action.prototype.getText = function() {
    /*Fetches the `_displayText` attribute.

    Returns:
        str: The `_displayText` attribute of the calling instance.
    */
    return this._displayText;
}

s.Action.prototype.getAlign = function() {
    /*Fetches the `_align` attribute.

    Returns:
        str: The `_align` attribute of the calling instance.
    */
    return this._align;
}

s.Action.prototype.setAlign = function(align) {
    /*Sets the `_align` attribute.

    Args:
        align (str): Assigned to the `_align` attribute of the calling
            instance.

    Returns:
        Action: The calling instance.
    */
    this._align = align;
    return this;
}

s.Action.prototype.setChoose = function(chooseFunc) {
    /*Sets the `_userScriptChoose` attribute.

    Args:
        chooseFunc (func, optional): The function to assign to the
            calling instance's `_userScriptChoose` attribute. Defaults
            to a function that returns the first element in the `_array`
            attribute.
    */
    this._userScriptChoose = chooseFunc || function() {
        return this._array[0];
    }
    return this;
}

s.Action.prototype.check = function() {
    /*Uses the `_userScriptCheck` attribute to check whether the
    action's link should be displayed.

    Returns:
        bool: The value of the attribute `_userScriptCheck`, if it is a
            boolean, or the return value of `_userScriptCheck`, if it is
            a function.
    */
    if (typeof(this._userScriptCheck) === 'boolean') {
        return this._userScriptCheck;
    } else {
        return this._userScriptCheck();
    }
}

s.Action.prototype.choose = function() {
    /*Uses the `_userScriptChoose` attribute to choose an outcome from
    the action.

    Returns:
        Outcome: `null`, if the action is empty, otherwise return the
            value of `_userScriptChoose`.
    */
    if (this.length() === 0) {
        return null;
    } else {
        return this._userScriptChoose();
    }
}

s.Action.prototype.addOutcome = function(
        func, targetPsg, chooseFunc, embed, nobreak
    ) {
    /*Adds an outcome to the calling instance.

    Args:
        func (func, optional): If provided, this function will be
            carried out just prior to loading the node associated with
            `targetPsg`.
        targetPsg (str, optional): The title of a passage. If provided,
            the outcome will end by loading the node associated with
            this passage. If no such node exists, one will be created.
        chooseFunc (func or string, optional): If a function is
            provided, will replace the calling instance's current
            `_userScriptChoose` attribute. If the string, 'random', is
            provided, it will be converted to a function that chooses
            an outcome uniformly from all possible outcomes.
        embed (bool, optional): If `true`, the node associated with 
            `endPsgTitle` will be embedded in the currently loaded page.
            Defaults to the value of `st.page._continuous`.
        nobreak (bool, optional): Defaults to false. Set to true to omit
            the scene break when embedding.

    Returns:
        Action: The calling instance.

    Raises:
        Error: If neither the `targetPsg` nor the `func` arguments are
            provided.
    */
    if (targetPsg == null && func == null) {
        throw new Error(
            's.addOutcome():\n' +
            'outcome must load a node or execute a function'
        );
    }

    if (chooseFunc === 'random') {
        chooseFunc = function() {
            return this._array.random();
        }
    }

    var targetNode;
    if (targetPsg != null) {
        targetNode = s.getNode(targetPsg);
        if (targetNode === undefined) {
            targetNode = new s.Node(targetPsg);
        }
    }

    var carryOutFunc;
    if (targetPsg == null) {
        carryOutFunc = func;
    } else if (func == null) {
        carryOutFunc = function() {
            st.page.load(targetNode, embed, nobreak);
        }
    } else {
        carryOutFunc = function() {
            func();
            st.page.load(targetNode, embed, nobreak);
        }
    }

    this.push(new s.Outcome(carryOutFunc));
    if (chooseFunc != null) {
        this.setChoose(chooseFunc);
    }

    return this;
}
/* twine-user-script #5: "0050-ActionList.js" */
/*Uses: List, Action.

Builds the `ActionList` class.

*/

s.ActionList = function(fixedEnd) {
    /*A subclass of List whose instance can contain only actions.

    Args:
        fixedEnd (int or bool, optional): If an integer, assigned to
            `_fixedEnd` attribute. If a boolean value, converted to 0 or
            1 before being assigned. Defaults to 0.

    Attributes:
        _array (arr): The embedded array of `Action` objects.
        _fixedEnd (int): Indicates how many elements at the end of the
            array to keep fixed in place.

    */
    
    s.List.call(this, fixedEnd);
    return this;
};

s.ActionList.prototype = Object.create(s.List.prototype);

Object.defineProperty(s.ActionList.prototype, 'constructor', {
    value: s.ActionList,
    enumerable: false,
    writable: true
});

s.ActionList.prototype._verify = function(obj) {
    /*(override) Members of an `ActionList` must be `Action` objects.

    Args:
        obj (obj): The object to test.

    Returns:
        bool: `true` if the object is an `Action`, `false` otherwise.
    */
    return (obj instanceof s.Action);
}

s.ActionList.prototype.addAction = function(
        text, carryOutFunc, checkFunc, index
    ) {
    /*This method is for adding a simple action with one outcome to the
    list.

    Args:
        text (str): The display text of the action.
        carryOutFunc (func, optional): The function to be executed when
            the action is taken. Defaults to a function that does
            nothing.
        checkFunc (func or bool, optional): Used to determine whether
            the action should be displayed. Defaults to `true`.
        index (int, optional): Where in the embedded array the new
            action should be inserted. Defaults to the end of the array.

    Returns:
        ActionList: The calling instance.
    */
    if (index == null) {
        index = this.length();
    }
    var outcome = new s.Outcome(carryOutFunc);
    var action = new s.Action(text, checkFunc);
    action.push(outcome);
    this.insert(index, action);
    return this;
}

s.ActionList.prototype.getAction = function(actionText) {
    /*Returns the action from the list whose display text matches the
    given argument. If no such action exists, returns null.

    Args:
        actionText (str): The display text to search for.

    Returns:
        Action: The matching `Action` object, if found.
        null: If no match is found.
    */
    var action;
    for (var i = 0; i < this.length(); i++) {
        action = this.get(i);
        if (action.getText() === actionText) {
            return action;
        }
    }
    return null;
}
/* twine-user-script #6: "0060-Node_.js" */
/*Uses: ActionList.

Builds the `Node` class and defines some associated global variables.
Creates an instance of `Node` (`s.root`) to serve as the root of the
node system. The root node is associated with the passage whose title is
is `Root`. Such a passage must exist and it is the first passage visited
after the `Start` passage.

Attributes:
    s.nodes (map of <<SC Passage>> to Node): Maps SugarCube `Passage`
        objects to associated `Node` objects. Used to keep a record of
        nodes created and to facilitate looking up nodes by passage
        titles.
    s.specialPsgs (arr of str): List of titles of SC special passages to
        be excluded from use as nodes.
    s.root (Node): A node associated with the required "Root" passage.
        It is the first node loaded in the game.

*/

s.nodes = new Map();

s.specialPsgs = [
    'PassageDone', 'PassageFooter', 'PassageHeader', 'PassageReady', 'Start', 
    'StoryAuthor', 'StoryBanner', 'StoryCaption', 'StoryDisplayTitle',
    'StoryInit', 'StoryInterface', 'StoryMenu', 'StorySettings', 'StoryShare',
    'StorySubtitle', 'StoryTitle'
];

s.getNode = function(psgTitle) {
    /*Returns the Node object associate with the given passage title.

    Args:
        psgTitle (str): The passage title to look for.

    Returns:
        node: The node associated with the given passage title.
    */
    return s.nodes.get(Story.get(psgTitle));
}

s.Node = function(psgTitle, subCount, func, outOfChar) {
    /*A wrapper around a passage containing a list of `Action` objects.

    Structurally, a node is a list of actions with a passage for the
    narrative description, and some additional methods. As such, it is
    implemented as a subclass of `ActionList`.

    The associated passage may have slots available for dynamically
    generated text substitutions. The `subCount` property should match
    the number of available text substitutions. It is there for a
    redundancy check to prevent the error of sending the wrong number of
    text substitutions when loading a node.

    Node objects, and their associated Action and Outcome objects,
    should be built on `s` so they are not stored in the player's local
    storage. As such, they will not be saved from session to session, so
    they should not be changed dynamically during gameplay.

    Args:
        psgTitle (str): The title of the passage to assign to the
            `_passage` attribute.
        subCount (int, optional): Assigned to `_subCount`. Defaults to
            0.
        func (func or null, optional): Assigned to `_userScript`.
            Defaults to null.
        outOfChar (bool, optional): Assigned to `_outOfChar`. Defaults
            to `false`.

    Raises:
        Error: If the given passage title does not exist, is a special
            passage, or has already been assigned to a node.

    Attributes:
        _array (arr): The embedded array of `Action` objects.
        _fixedEnd (int): Indicates how many elements at the end of the
            array to keep fixed in place. Defaults to 0.
        _passage (<<SC Passage>>): The passage associated with the node.
        _excerpt (str): Give an excerpt of the associated passage, much
            like SugarCube's `Passage._excerpt`.
        _subCount (int): The number of expected text substitutions in
            the associated passage.
        _userScript (func or null): The function to execute upon loading
            the node. It runs immediately before the loading of the
            passage.
        _outOfChar (bool): `true` if the node's content lies outside the
            narrative flow of the story (e.g., help screen or character
            sheet).

    */

    s.ActionList.call(this);
    if (!Story.has(psgTitle)) {
        throw new Error(
            'Node():\n' +
            'there is no passage titled "' + psgTitle + '"'
        );
    }
    if (s.specialPsgs.indexOf(psgTitle) >= 0) {
        throw new Error(
            'Node():\n' +
            'cannot assign a special passage to a node'
        );
    }
    var psg = Story.get(psgTitle);
    if (s.nodes.has(psg)) {
        throw new Error(
            'Node():\n' +
            'the passage "' + psgTitle + '" already belongs to a node'
        );
    }
    this._passage = psg;
    this._excerpt = null;
    s.nodes.set(psg, this);
    this._subCount = subCount || 0;
    this._userScript = func;
    this._outOfChar = (outOfChar === undefined) ? false : outOfChar;
    return this;
};

s.Node.prototype = Object.create(s.ActionList.prototype);

Object.defineProperty(s.Node.prototype, 'constructor', {
    value: s.Node,
    enumerable: false,
    writable: true
});

s.Node.prototype.getPassage = function() {
    /*Fetches the `_passage` attribute.

    Returns:
        <<SC Passage>>: The `_passage` attribute of the calling
            instance.
    */
    return this._passage;
}

s.Node.prototype.getExcerpt = function() {
    /*Fetches the excerpt of the associated passage.

    Returns:
        str: The `_excerpt` property, if it is non-null; otherwise, the
            `_excerpt` property of the associated passage.
    */
    var excerpt = this._excerpt;
    if (excerpt === null) {
        excerpt = this._passage._excerpt;
    }
    return excerpt;
}

s.Node.prototype.getSubCount = function() {
    /*Fetches the `_subCount` attribute.

    Returns:
        int: The `_subCount` attribute of the calling instance.
    */
    return this._subCount;
}

s.Node.prototype.setSubCount = function(num) {
    /*Sets the `_subCount` attribute. Can only change it from its
    default value of 0 one time, to prevent unwanted errors. Sub counts
    are not meant to dynamically change.

    Args:
        num (int): Assigned to the `_subCount` attribute of the calling
            instance.

    Returns:
        Action: The calling instance.

    Raises:
        Error: If used when `_subCount` is not 0.
    */
    if (this._subCount !== 0) {
        throw new Error(
            'Node.setSubCount():\n' +
            'can only set sub count once'
        );
    }
    this._subCount = num;
    return this;
}

s.Node.prototype.onLoad = function() {
    /*Does nothing if `this._userScript` is `null` or `undefined`,
    otherwise executes `this._userScript`.

    Returns:
        Returns the same value as `this._userScript`.
    */
    if (this._userScript == null) {
        return;
    } else {
        return this._userScript();
    }
}

s.root = new s.Node('Root');
/* twine-user-script #7: "0070-Version_.js" */
/*Uses: standard.

Builds and instantiates the `Version` class.

Attributes:
    s.version (Version): A `Version` instance for other classes to use.

*/

s.Version = function(major, minor, patch) {
    /*Keeps track of a three-part version number.

    The version number is converted to a single integer and stored in
    `Config.saves.version`.

    Args:
        major (int, optional): Assigned to `_major`. Defaults to 0.
        minor (int, optional): Assigned to `_minor`. Defaults to 0.
        patch (int, optional): Assigned to `_patch`. Defaults to 1, if
            both `_major` and `_minor` are 0; otherwise, defaults to 0.

    Attributes:
        _major (int): A nonnegative integer less than 1000.
        _minor (int): A nonnegative integer less than 1000.
        _patch (int): A nonnegative integer less than 1000. Cannot be 0
            if both `_major` and `_minor` are 0.

    */

    major = major || 0;
    minor = minor || 0;
    patch = patch || ((major === 0 && minor === 0) ? 1 : 0);
    this.set(major, minor, patch);
    return this;
}

s.Version.prototype.asArray = function() {
    /*Fetches the version number as an array.

    Returns:
        arr of int: The version number as an array of three integers.
    */
    return [this._major, this._minor, this._patch];
}

s.Version.prototype._arrToStr = function(arr) {
    /*Converts a version number formatted as an array to a string,
    formatted with dot separators. If the `_patch` attribute is 0, it is
    not included in the string.

    Args:
        arr (arr of int): The version number array to format.

    Returns:
        str: The formatted version number.
    */
    var string = arr[0].toString() + '.' + arr[1].toString();
    if (arr[2] > 0) {
        string += '.' + arr[2].toString();
    }
    return string;
}

s.Version.prototype._strToArr = function(string) {
    /*Converts a version number formatted as a string to an array.

    Args:
        string (str): The string to convert.

    Returns:
        arr of int: The converted string.
    */
    var arr = string.split('.').map(function(part) {
        return parseInt(part, 10);
    });
    if (arr.length === 2) {
        arr.push(0);
    }
    return arr;
}

s.Version.prototype._arrToInt = function(arr) {
    /*Converts a version number formatted as an array to a single
    integer.

    Args:
        arr (arr of int): The version number array to convert.

    Returns:
        int: The converted integer.
    */
    return 1000000 * arr[0] + 1000 * arr[1] + arr[2];
}

s.Version.prototype._intToArr = function(num) {
    /*Converts a version number formatted as an integer to an array.

    Args:
        num (int): The version number integer to convert.

    Returns:
        arr of int: The converted array.
    */
    var arr = [0,0,0];
    arr[2] = num % 1000;
    num = (num - arr[2])/1000;
    arr[1] = num % 1000;
    arr[0] = (num - arr[1])/1000;
    return arr;
}

s.Version.prototype.intToStr = function(num) {
    /*Converts a version number formatted as an integer to a string with
    dot separators.

    Args:
        num (int): The version number integer to convert.

    Returns:
        str: The converted string.
    */
    return this._arrToStr(this._intToArr(num));
}

s.Version.prototype.asString = function() {
    /*Returns the version number as a string, with dot separators. If
    the `_patch` attribute is 0, it is not included in the string.

    Returns:
        str: The version number as a string.
    */
    return this._arrToStr(this.asArray());
}

s.Version.prototype.asInteger = function() {
    /*Fetches the version number as a potentially nine-digit integer.
    For example, 32.3.86 corresponds to 32003086.

    Returns:
        int: The version number as an integer.
    */
    return this._arrToInt(this.asArray());
}

s.Version.prototype.set = function(major, minor, patch) {
    /* Sets the version number.

    Args:
        major (int): Assigned to calling instance's `_major` attribute.
        minor (int): Assigned to calling instance's `_minor` attribute.
        patch (int): Assigned to calling instance's `_patch` attribute.

    Returns:
        Version: The calling instance.

    Raises:
        Error: If any parameter is not a nonnegative integer less than
            1000, or if all parameters are 0.
    */
    for (var i = 0; i < 3; i++) {
        if (arguments[i] !== parseInt(arguments[i], 10) ||
            arguments[i] < 0 ||
            arguments[i] > 999) {
            throw new Error(
                'Version._init():\n' +
                'numbers must be nonnegative integers less than 1000'
            );
        }
    }
    if (major + minor + patch === 0) {
        throw new Error(
            'Version._init():\n' +
            'parts cannot all be 0'
        );
    }
    this._major = major;
    this._minor = minor;
    this._patch = patch;
    Config.saves.version = this.asInteger();
    return this;
}

s.version = new s.Version();
/* twine-user-script #8: "0080-DebugController_.js" */
/*Uses: standard.

Builds the `DebugController` class and instantiates it. Then adds the
`debugOn` boolean variable to `settings`, adds a toggle switch for it to
the setting menu in the UI Bar, and binds the relevant methods to the UI
toggle switch.

Attributes:
    s.debCon (DebugController): A `DebugController` instance for use by
        other classes.
    ss.debugOn (bool): `true` if debug mode is on, `false` otherwise.

*/

s.DebugController = function() {
    /*Controls debug mode.

    Debug mode is a developer mode that can be used to activate certain
    capabilities and functionalities not present in ordinary gameplay.
    The state of debug mode is stored in the boolean property `debugOn`
    in SugarCube's `settings` namespace, which has `ss` as an alias.

    Attributes:
        _cheaCode (arr of str): An array of passage title strings.
            Loading the nodes associated to these passage titles in the
            given order toggles the state of debug mode.

    */
    
    this._cheatCode = [];
    return this;    
};

s.DebugController.prototype.getCheat = function() {
    /*Fetches the `_cheaCode` attribute.

    Returns:
        arr of str: The `_cheatCode` attribute of the calling
            instance.
    */
    return this._cheatCode;
}

s.DebugController.prototype.setCheat = function(psgTitles) {
    /*Sets the `_cheatCode` attribute.

    Args:
        psgTitles (arr of str): Assigned to the `_cheatCode` attribute
            of the calling instance.

    Returns:
        DebugController: The calling instance.
    */
    this._cheatCode = psgTitles;
    return this;
}

s.DebugController.prototype.checkUIBar = function() {
    /*By default, SugarCube's UI Bar is only visible during debug mode.
    This method ensures that the UI Bar is in the correct state.

    Returns:
        DebugController: The calling instance.
    */
    if (ss.debugOn) {
      UIBar.unstow().show();
    } else {
      UIBar.hide().stow();
    }
    return this;
}

s.DebugController.prototype.onInit = function() {
    /*Runs on story initialization.
    */
    this.checkUIBar();
    return;
}

s.DebugController.prototype.onChange = function() {
    /*Runs when the debug state changes. Refreshes the current passage
    in order to display visible changes that might occur with the state
    change.
    */
    this.checkUIBar();
    Engine.show();
    return;
}

s.DebugController.prototype.toggle = function() {
    /*Toggles the debug state.

    Returns:
        DebugController: The calling instance.
    */
    ss.debugOn = !ss.debugOn;
    Setting.save();
    this.onChange();
    return this;
}

s.debCon = new s.DebugController();

Setting.addToggle('debugOn', {
    label:      'debug mode',
    onInit:     s.debCon.onInit.bind(s.debCon),
    onChange:   s.debCon.onChange.bind(s.debCon)
});
/* twine-user-script #9: "0090-SavesManager_.js" */
/*Uses: DebugController_, Version

Builds and instantiates the `SavesManager` class. Then alters SC's
default saves dialog.

Attributes:
    s.savesMgr (SavesManager): A `SavesManager` instance for use by
        other classes.

*/

s.SavesManager = function(bkMarks, block) {
    /*Manages the autosave, bookmark(s), and checkpoints.

    Args:
        bkMarks (int): Assigned to the `_bkMarks` attribute. Defaults to
            1. Also synchronized to SC's maximum allowed save slots.
        block (bool, optional): Assigned to the `_block` attribute.
            Defaults to `false`.

    Attributes:
        _block (bool): If `true`, will block the loading of saves whose
            version does not match the current version.
        _bkMarks (int): The maximum number of allowed bookmarks.

    */
    
    this._block = (block == null) ? false : block;
    this._bkMarks = (bkMarks == null) ? 0 : bkMarks;
    this._setMaxSaves();
    return this;    
};

s.SavesManager.prototype._setMaxSaves = function() {
    /*Sets the maximum number of allows saves in SugarCube.
    */
    Config.saves.slots = this._bkMarks;
}

s.SavesManager.prototype.setBlock = function(block) {
    /*Sets the `_block` attribute.

    Args:
        block (bool): Assigned to the `_block` attribute of the calling
            instance.

    Returns:
        SavesManager: The calling instance.
    */
    this._block = block;
    return this;
}

s.SavesManager.prototype.setBkMarks = function(bkMarks) {
    /*Sets the `_bkMarks` attribute and syncs it with SC's maximum
    allowed save slots.

    Args:
        bkMarks (int): Assigned to the `_bkMarks` attribute of the
            calling instance.

    Returns:
        SavesManager: The calling instance.
    */
    this._bkMarks = bkMarks;
    this._setMaxSaves();
    return this;
}

s.SavesManager.prototype.get = function(num) {
    /*Fetches save objects by their label in the saves dialog box. Saves
    are numbered in the saves dialog box starting with 1.

    Args:
        num (int): The label whose save to retrieve. If 0, retrieves the
            autosave.

    Returns:
        <<SC save obj>>: The retrieved save object.
    */
    if (num === 0) {
        return Save.autosave.get();
    } else {
        return Save.slots.get(num - 1);
    }
}

s.SavesManager.prototype.load = function(num) {
    /*Loads save objects by their label in the saves dialog box. Saves
    are numbered in the saves dialog box starting with 1.

    Blocks the load if the calling instance's `_block` is true and the
    version number of the save object doesn't match the current version
    number.

    Args:
        num (int): The label whose save to load. If 0, loads the
            autosave.
    */
    if (this._block) {
        var verInt = this.get(num).version;
        if (verInt !== s.version.asInteger()) {
            var verStr = s.version.intToStr(verInt);
            alert(
                'save file is from version ' + verStr + ';\n' +
                'current version is ' + s.version.asString() + ';\n' + 
                'unable to load.'
            );
            return;
        }
    }
    if (num === 0) {
        Save.autosave.load();
    } else {
        Save.slots.load(num - 1);
    }
    return;
}

s.SavesManager.prototype.saveBkMark = function() {
    /*If there is an empty bookmark slot, saves a bookmark after
    confirming with the player; otherwise, alerts that no bookmarks
    slots are available.

    Returns:
        SavesManager: The calling instance.
    */
    var filled = Save.slots.count();
    var empty = this._bkMarks - filled;
    if (empty > 0) {
        if (confirm(
            'Save bookmark? You have ' + empty + ' of ' + this._bkMarks +
                ' remaining.\n\n' +
            '(If you just want to quit and resume later, you should not need ' +
                'to save. See the info screen for details.)'
        )) {
            Save.slots.save(filled);
        }
    } else {
        alert('All bookmarks already filled. Restart to delete them.');
    }
    return this;
}

s.savesMgr = new s.SavesManager();

$(document).on(':dialogopened', function (ev) {
    /*Alters SC's saves dialog by changing the title to 'Bookmarks',
    showing only filled save slots, removing the autosave from the
    display, removing the bottom button bar, and removing the delete
    buttons if debug mode is not on.
    */
    if (Dialog.isOpen('saves')) {
        $('#ui-dialog-title').html('Bookmarks');
        $('#saves-list').find('tr:gt(' + Save.slots.count() + ')').remove();
        $('tr:first-child').remove();
        $(ev.target).children('ul.buttons').remove();
        if (!ss.debugOn) {
            $('button[id^="saves-delete"]').remove();
        }
    }
});
/* twine-user-script #10: "0100-InfoNode_.js" */
/*Uses: Node_.js

Builds the `InfoNode` class and adds a function to
`s.autosave.necessary`, preventing autosave from occurring when loading
an InfoNode.

*/

s.InfoNode = function(psgTitle, checkFunc) {
    /*A node used for non-narrative content.

    `InfoNode` is a subclass of `Node`. It is a special kind of node
    which lies outside the narrative context of the game. Visiting an
    info node does not trigger an autosave. An info node has a default
    action with text, 'return to story', that takes the player back to
    the last non-info node by reloading the last autosave.

    @param {String} psgTitle - The title of the associated passage.
    @param {Function|Boolean} checkFunc (optional) - The function to
    call when checking if the `return to story` action should be
    displayed. Should return a boolean. If a boolean is provided, simply
    returns that boolean. Defaults to true.

    Args:
        psgTitle (str): The title of the passage assigned to the
            `_passage` attribute.
        checkFunc (func or bool, optional): The function to call when
            checking if the `return to story` action should be
            displayed. Should return a boolean. If a boolean is
            provided, simply returns that boolean. Defaults to true.

    Attributes:
        _array (arr): The embedded array of `Action` objects.
        _fixedEnd (int): Indicates how many elements at the end of the
            array to keep fixed in place. Defaults to 0.
        _passage (<<SC Passage>>): The passage associated with the node.
        _subCount (int): The number of expected text substitutions in
            the associated passage. Defaults to 0.
        _userScript (func or null): The function to execute upon loading
            the node. It runs immediately before the loading of the
            passage associated with the calling node. Defaults to
            `null`.
        _outOfChar (bool): `true` if the node's content lies outside the
            narrative flow of the story (e.g., help screen or character
            sheet). Defaults to `true`.

    */
    
    s.Node.call(this, psgTitle);

    this._outOfChar = true;
    this.addAction('return to story', Save.autosave.load, checkFunc);

    return this;
};

s.InfoNode.prototype = Object.create(s.Node.prototype);

Object.defineProperty(s.InfoNode.prototype, 'constructor', {
    value: s.InfoNode,
    enumerable: false,
    writable: true
});

s.autosave.necessary.push(function() {
    return (!(s.getNode(passage()) instanceof s.InfoNode));
});
/* twine-user-script #11: "0110-Parser_.js" */
/*Uses: Node_.

Build the `Parser` class and instantiates it.

Attributes:
    st.parser (Parser): A `Parser` instance for use by other classes.

*/

s.Parser = function() {
    /*Prepares passage text for use by SugarCube.

    A Parser object manages the conversion of the given passage text to
    the actual passage text used by SugarCube to display information.

    There is one instance (`st.parser`), built in State.variables, so
    its state can be stored in SugarCube's history. (This is needed,
    because the parser tracks dynamically generated text substitutions.)
    The class must therefore be made compatible with SugarCube by having
    `clone ()` and `toJSON()` methods, and no recursive objects or
    object sharing. To achieve this, we also require it to have a
    constructor with no arguments and to have all its properties be SC
    supported types.

    Attributes:
        _textSubMap (map of str to arr of (str or func)): Maps passage
            titles to arrays of text subs. A text sub can be a simple
            string or a functions returning a string.
            
    */

    this._textSubMap = new Map();
    return this;    
};

s.Parser.prototype._init = function(obj) {
    /* Needed for SugarCube compatibility. */
    Object.keys(obj).forEach(function (pn) {
        this[pn] = clone(obj[pn]);
    }, this);
    return this;
};

s.Parser.prototype.clone = function () {
    /* Needed for SugarCube compatibility. */
    return (new s.Parser())._init(this);
};

s.Parser.prototype.toJSON = function () {
    /* Needed for SugarCube compatibility. */
    var newPC = {};
    Object.keys(this).forEach(function (pn) {
        newPC[pn] = clone(this[pn]);
    }, this);
    return JSON.reviveWrapper(
        '(new s.Parser())._init($ReviveData$)', newPC
    );
};

s.Parser.prototype.getSubs = function(psgTitle) {
    /*Fetches the array of text subs associated with the given passage
    title.

    Args:
        psgTitle (str): The title of the passage whose text subs to
            fetch.

    Returns:
        arr of (str or func): The array of text subs associated with the
            given passage title.
    */
    return this._textSubMap.get(psgTitle);
}

s.Parser.prototype.setSubs = function(psgTitle, subArray) {
    /*Sets the text subs for the given passage.

    Args:
        psgTitle (str): The title of the passage whose text subs are to
            be set.
        subArray (arr of (str or func)): The array of text subs to
            assign to the given passage.

    Returns:
        Parser: The calling instance.

    Raises:
        Error: If the given passage is not associated with a node, the
            number of given text substitutions does not match the given
            passage, or any of the given text substitutions is the wrong
            data type.
    */
    var node = s.getNode(psgTitle);
    if (node === undefined) {
        throw new Error(
            'Parser.setSubs():\n' +
            '"' + psgTitle + '" does not correspond to a node.'
        );
    }
    if (node.getSubCount() !== subArray.length) {
        throw new Error(
            'Parser.setSubs():\n' +
            'unexpected number of text substitutions'
        );
    }
    if (!subArray.every(function(element) {
        return (typeof(element) === 'string' ||
                typeof(element) === 'function');
    })) {
        throw new Error(
            'Parser.setSubs():\n' +
            'text substitutions must be strings or' +
            'functions that return strings'
        );
    }
    this._textSubMap.set(psgTitle, subArray);
    return this;
}

s.Parser.prototype.insertTextSubs = function(psgTitle, text) {
    /*Fetches the array of text substitutions corresponding to
    `psgTitle` from the instance's `_textSubMap` attribute (or `[]` if
    there is no such array), then replaces occurrences of `{<number>}`
    in the given text with corresponding elements from that array.

    Does nothing if the node associated with `psgTitle` has a sub count
    of 0.

    Args:
        psgTitle (str): The title of the passage being processed. This
            passage title must correspond to a node. Passing a title
            that does not correspond to a node could have unexpected
            behavior.
        text (str): The text to process.

    Returns:
        str: The processed text.

    Raises:
        Error: If the passage's node expects more substitutions than are
            provided in the the parser's `_textSubMap` attribute.
        Error: If the passage text contains markup of the form '{n}',
            where n is larger than expected by the passage's node.
        Error: If the passage text contains markup of the form '{n}'
            repeated more than once with the same value of n.
    */
    var subArray = (this.getSubs(psgTitle) || []);
    subArray = subArray.map(function(element) {
        if (typeof(element) === 'function') {
            return element();
        } else {
            return element;
        }
    });

    var psg = Story.get(psgTitle);
    var node = s.nodes.get(psg);
    var subCount = node.getSubCount();
    if (subCount === 0) {
        return text;
    }

    var psgId = psg.domId;
    var subsFound = new Set();
    var regex = /\{(\d+?)\}/;
    var processedText = text;
    var result, index;
    while (true) {
        result = regex.exec(processedText);
        if (result === null) {
            if (subsFound.size < subCount) {
                throw new Error(
                    'too few text substitutions in passage, "' +
                    psgTitle + '"'
                );
            }
            return processedText;
        }
        index = parseInt(result[1], 10);
        if (index >= subCount) {
            throw new Error(
                'text substitution index out of range in passage, "' +
                psgTitle + '"'
            );
        }
        if (subsFound.has(index)) {
            throw new Error(
                'duplicate text substitution index in passage, "' +
                passage.title + '"'
            );
        }
        subsFound.add(index);
        processedText = (
            processedText.slice(0, result.index) +
            subArray[index] +
            processedText.slice(result.index + result[0].length)
        );
    }
}

s.Parser.prototype.showDetails = function(description, id) {
    /*Inserts the given description into the element with the given id
    and clears all other elements with class `.description`. If the
    element with the given id already contains the given description,
    the function simply clears it.

    Args:
        description (str): The description to insert.
        id (str): The HTML element id of the container into which to
            insert the description.
    */
    var text = jQuery("#" + id).html();     // store the current content
                                            // for comparison

    jQuery(".description").empty()          // clear all elements

    jQuery("#" + id).wiki(description);     // insert the description

    if (text === jQuery("#" + id).html()) { // empty content if already
        jQuery("#" + id).empty();           // present
    }

    return;
}

s.Parser.prototype.procDetailMarkup = function(psgTitle, text) {
    /*Replaces occurrences of `{<link text>|id}` in text with links that
    reveal a description. The description is found in a corresponding
    occurrence of `{?id|description}` which is replaced by a div element
    into which the description appears. The HTML id of the div element
    is determined by both the id in the markup and the given `psgTitle`.
    The appearance of the description is controlled by the parser's
    `showDetails` method.

    The link text cannot begin with a `?` and cannot contain a `|`. The
    id must contain only letters, numbers, and `_`, and must begin with
    a letter.

    Args:
        psgTitle (str): The title of the passage being processed.
        text (str): The text of the passage being processed.

    Returns:
        str: The processed text.
    */
    var psg = Story.get(psgTitle);
    var psgId = psg.domId;

    var linkRegex = /\{(.+?)\|([a-zA-Z][0-9a-zA-Z_]*?)\}/;

    var processedText = text;

    var cut = [0,0,0,0];         // indices at which to cut the given
                                 // text

    var part = ['','','','','']; // substrings to concatenate in order
                                 // to build the new text

    var j;                       // temporary storage, used in building
                                 // `cut`

    var linkResult, linkText, linkId, elementId;
    var descRegex, descResult, descText, descLoc;
    while (true) {
        linkResult = linkRegex.exec(processedText);

        if (linkResult === null) {
            return processedText.replace(
                /\{\?([a-zA-Z][0-9a-zA-Z_]*?)\|(.+?)\}/g, ''
            );
        }
        
        linkId = linkResult[2];
        descRegex = new RegExp(
            '\\{\\?' + linkId + '\\|(.+?)\\}'
        );
        descResult = descRegex.exec(processedText);

        if (descResult === null) {
            throw new Error(
                'link markup without description markup in passage, "' +
                psgTitle + '"'
            );
        }

        linkText = linkResult[1];
        descText = descResult[1];
        elementId = psgId + '-examine-' + linkId;

        j = linkResult.index < descResult.index ? 0 : 2;
        cut[j] = linkResult.index;
        cut[j+1] = linkResult.index + linkResult[0].length;
        cut[2-j] = descResult.index;
        cut[3-j] = descResult.index + descResult[0].length;

        part[0] = processedText.slice(0, cut[0]);
        part[2] = processedText.slice(cut[1], cut[2]);
        part[4] = processedText.slice(cut[3])

        part[j+1] = (
            '<<link "' + linkText + '">>' +
                '<<run st.parser.showDetails(' + 
                    '"' + descText + '", "' + elementId + '"' +
                ')>>' +
            '<</link>>'
        );

        part[3-j] = (
            '<div id="' + elementId + '" class="description">' +
            '</div>'
        );

        processedText = part.join('');
    }
}

s.Parser.prototype.addContainers = function(psgTitle, text) {
    /*Wraps the given text in a `body` container; adds an `action`
    container for the action links; adds a `next` container in case the
    next node is to be loaded without a passage transition. The HTML id
    of the containers is determined by `psgTitle`.

    Args:
        psgTitle (str): The title of the passage being processed.
        text (str): The text to process.

    Returns:
        str: The processed text.
    */
    var psg = Story.get(psgTitle);
    return (
        '<div id="' + psg.domId + '-body">\n\n' +
            text + '\n\n' +
        '</div>\n\n' + 
        '<div id="' + psg.domId + '-actions"></div>\n\n' +
        '<div id="' + psg.domId + '-next"></div>'
    );

}

s.Parser.prototype.removeBreaks = function(text) {
    /*Removes line breaks from the given text.

    Args:
        text (str): The text to process.

    Returns:
        str: The processed text.
    */
    var processedText = text.replace(/\r/g, '');
    processedText = processedText.replace(/^\n+|\n+$/g, '');
    processedText = processedText.replace(/\n+/g, ' ');
    return processedText;
}

s.Parser.prototype.procAllMarkup = function(psgTitle, text, time) {
    /*Processes the special node markup in the given passage (inserts
    text subs, processes the detail markup, adds the containers, and
    removes breaks. Does nothing if the given passage is not associated
    with a node. Returns the processed text.

    The optional `time` parameter is used to set the moment in SC's
    history from which to draw the values of variables. It allows for
    the use of variables in passage content.

    Args:
        psgTitle (str): The title of the passage being processed.
        text (str): The text of the passage being processed.
        time (int, optional): A nonnegative integer that defaults to
            zero. Sets the moment in history to use when parsing. A
            value of 0 denotes the current moment. A value of n > 0
            means to go back n moments in SC's history.
    */
    var node = s.getNode(psgTitle);
    if (node === undefined) {
        return text;
    }

    time = time || 0;
    if (time > 0) {
        s.loadVars(time);
    }

    var processedText = text;
    processedText = this.insertTextSubs(psgTitle, processedText);
    processedText = this.procDetailMarkup(psgTitle, processedText);
    processedText = this.addContainers(psgTitle, processedText);
    processedText = this.removeBreaks(processedText);

    if (time > 0) {
        s.loadVars(0);
    }

    return processedText;
}

st.parser = new s.Parser();
/* twine-user-script #12: "0120-Page_.js" */
/*Uses: InfoNode, Parser_, DebugController_.

Builds the `Page` class, instantiates it, and creates functions for
managing SC's display of incoming passages.

Attributes:
    st.page (Page): A `Page` instance for use by other classes.
    s.preProcText (arr of arr(str, func)): Each element of this array is
        a size-2 array, the first element of which is the title of a
        passage, and the second element of which is a function to apply
        to that passage's text before SC's text processing. The function
        should take a string as an argument and return a string.

*/

s.Page = function() {
    /*Manages the content of the current viewable area in the browser.

    A `Page` object represents the content which is displayed on the
    screen. Traditionally in SugarCube, this is just a passage. But with
    the node system, multiple passages can be displayed at a time, in
    order. The first passage is the main one and the one which SugarCube
    regards as being displayed. The other passages are displayed inside
    the first passage.

    There is one instance (`st.page`), built on State.variables, so its
    state can be stored in SugarCube's history. (This allows SugarCube
    to rebuild the page upon a browser refresh or upon loading a save
    file.) The class must therefore be made compatible with SugarCube by
    having `clone()` and `toJSON()` methods, and no recursive objects or
    object sharing. To achieve this, we also require it to have a
    constructor with no arguments and to have all its properties be SC
    supported types.

    Attributes:
        _embeddedPsgs (arr of str): Array of embedded passage titles;
            does not include the first (main) passage.
        _noBreakFlags (arr of bool): Array of nobreak flags (true if
            passage was embedded without a scene break, i.e. a visual
            separator between embedded passages)
        _continuous (bool): Defaults to `false`. Set to `true` to make
            the passages embed by default.

    */
    
    this._embeddedPsgs = [];
    this._noBreakFlags = [];
    this._continuous = false;
    return this;    
};

s.Page.prototype._init = function(obj) {
    /* Needed for SugarCube compatibility. */
    Object.keys(obj).forEach(function (pn) {
        this[pn] = clone(obj[pn]);
    }, this);
    return this;
};

s.Page.prototype.clone = function () {
    /* Needed for SugarCube compatibility. */
    return (new s.Page())._init(this);
};

s.Page.prototype.toJSON = function () {
    /* Needed for SugarCube compatibility. */
    var newPC = {};
    Object.keys(this).forEach(function (pn) {
        newPC[pn] = clone(this[pn]);
    }, this);
    return JSON.reviveWrapper(
        '(new s.Page())._init($ReviveData$)', newPC
    );
};

s.Page.prototype.ready = function(safe) {
    /*Throws an error if current passage is not associated with a node.

    Args:
        safe (bool, optional): If `true`, does not throw an error but
            returns `false` instead.

    Returns:
        bool: `true` if current passage is a node, `false` otherwise.

    Raises:
        Error: If current passage is not a node.
    */
    if (s.getNode(passage()) === undefined) {
        if (safe) {
            return false;
        }
        throw new Error(
            'Page.ready()\n' +
            'Passage is not associated to a node.'
        );
    }
    return true;
}

s.Page.prototype.length = function() {
    /*Fetches the number of embedded passages.

    Returns:
        int: The length of the `_embeddedPsgs` attribute.
    */
    return this._embeddedPsgs.length;
}

s.Page.prototype.getPsg = function(index) {
    /*Fetches the title of the embedded passage at the given index.

    Args:
        index (int): The index from which to retrieve the passage.

    Returns:
        str: The passage title at that index.
    */
    return this._embeddedPsgs[index];
}

s.Page.prototype.getFlag = function(index) {
    /*Fetches the no-break flag embedded passage at the given index.

    Args:
        index (int): The index from which to retrieve the no-break flag.

    Returns:
        str: The no-break flag at that index.
    */
    return this._noBreakFlags[index];
}

s.Page.prototype.isContinuous = function() {
    /*Used to check if passage-embedding is the default behavior.

    Returns:
        bool: The value of the `_continuous` attribute.
    */
    return this._continuous;
}

s.Page.prototype.setContinuous = function(val) {
    /*Sets the passage-embedding default behavior.

    Args:
        val (bool): The value assigned to the `_continuous` attribute.

    Returns:
        Page: The calling `Page` instance.
    */
    this._continuous = val;
    return this;
}

s.Page.prototype.innerPsg = function() {
    /*Returns the innermost passage on the page as a SC Passage object.

    Returns:
        <<SC Passage>>: The current passage if `_embeddedPsgs` is empty;
            otherwise, the last element of `_embeddedPsgs`
    */
    var psg;
    if (this._embeddedPsgs.length === 0) {
        psg = Story.get(passage());
    } else {
        var title = this._embeddedPsgs[this._embeddedPsgs.length - 1];
        psg = Story.get(title);
    }
    return psg;
}

s.Page.prototype.insertPsgText = function(psg, shellPsg, time, nobreak) {
    /*Inserts the given passage into the given shell passage, preceded
    by a scene break ("****"). The scene break is omitted if the
    optional `nobreak` is true.

    The optional `time` parameter is used to set the moment in SC's
    history from which to draw the values of variables. It allows for
    the use of variables in passage content. It should be a nonnegative
    integer. A value of 0 denotes the current moment. Defaults to zero.

    After processing the node markup, sets the `_excerpt` attribute of
    the node associated with the given passage in the same way that SC's
    `Passage.render()` does to `Passage._excerpt`. (See
    https://github.com/tmedwards/sugarcube-2/blob/
    7e13f2665c2df989ccd498d2d7162f58b9392192/src/passage.js#L220)

    Uses `Page.ready()` to check if the incoming passage corresponds to
    a node.

    Args:
        psg (<<SC Passage>>): The passage to embed.
        shellPsg (<<SC Passage>>): The passage into which to embed.
        time (int, optional): A nonnegative integer that defaults to
            zero. Sets the moment in history to use when parsing.
        nobreak (bool, optional): Defaults to false. Set to true to omit
            the scene break.

    Returns:
        Page: The calling `Page` instance.
    */
    this.ready();

    time = time || 0;
    if (time < 0) {
        s.loadVars(time);
    }

    var sceneBreak = nobreak ? '' : '<p style="text-align:center">****</p>';
    $('#' + shellPsg.domId + '-next').wiki(
        sceneBreak + st.parser.procAllMarkup(psg.title, psg.text)
    );

    var element = document.getElementById(psg.domId + '-body');
    var excerpt = element.textContent.trim();
    if (excerpt !== '') {
        const excerptRe = new RegExp(`(\\S+(?:\\s+\\S+){0,${7}})`);
        excerpt = excerpt.replace(/\s+/g, ' ').match(excerptRe);
    }
    s.nodes.get(psg)._excerpt = excerpt ? `${excerpt[1]}\u2026` : '\u2026';

    if (time < 0) {
        s.loadVars(0);
    }

    return this;
}

s.Page.prototype.takeAction = function(psgTitle, index) {
    /*Called when the player selects an action from a node. Uses
    `Page.ready()` to check if the current passage corresponds to a
    node. Before carrying out the resulting outcome, adds to the node
    history (i.e. adds to `st.path`).

    Args:
        psgTitle (str): The title of the passage whose node contains the
            actions to choose from.
        index (integer): The index of the action to take. (Recall that a
            node is a list of actions.)
    */
    this.ready();

    var psg = Story.get(psgTitle);
    var node = s.nodes.get(psg);
    var action = node.get(index);
    var outcome = action.choose();
    st.path.addEdge(
        node.length(),
        index,
        action.length(),
        action.indexOf(outcome)
    )

    return outcome.carryOut();

}

s.Page.prototype.insertActions = function(psg) {
    /*Takes the given SC Passage object, finds the node associated with
    it, and retrieves the actions from that node. For each action,
    checks if the action should be displayed. If it passes the check,
    adds a link for the corresponding action to the node's action div
    container.

    Uses `Page.ready()` to check if the incoming passage corresponds to
    a node.

    Args:
        psg (<<SC Passage>>): The passage into whose node to insert
            actions.

    Returns:
        Page: The calling `Page` instance.
    */
    this.ready();

    var node = s.nodes.get(psg);
    if (node === undefined) {
        return;
    }

    var psgTitle = psg.title;
    var psgId = psg.domId;
    var action;
    for (var i = 0; i < node.length(); i++) {
        action = node.get(i);
        if (action.check()) {
            $('#' + psgId + '-actions').wiki(
                '<p style="text-align:' + action.getAlign() + '">' +
                    '<<link "' + action.getText() + '">>' +
                        '<<run st.page.takeAction(' +
                            '"' + psgTitle + '", ' + i +
                        ')>>' +
                    '<</link>>' +
                '</p>'
            );
        }
    }
    return this;
}

s.Page.prototype.refreshActions = function() {
    /*Deletes the actions on the page and reinserts them. Can be used
    after dynamically changing variables on which action check functions
    depend.

    Uses `Page.ready()` to check if the incoming passage corresponds to
    a node.

    Returns:
        Page: The calling `Page` instance.
    */
    this.ready();

    var latestPsg = this.innerPsg();
    $('#' + latestPsg.domId + '-actions').empty();
    this.insertActions(latestPsg);
    return this;
}

s.Page.prototype.scrollToLast = function() {
    /*Scrolls to put the innermost passage at the top.

    Uses `Page.ready()` to check if the incoming passage corresponds to
    a node.

    Returns:
        Page: The calling `Page` instance.
    */
    this.ready();

    var headerHeight;
    var header = document.getElementById('header');
    if (header == null) {
        headerHeight = 0;
    } else {
        headerHeight = header.offsetHeight;
    }
    $('html, body').animate({
        scrollTop: (
            $('#' + this.innerPsg().domId + '-body').position().top -
            headerHeight - 16
        )
    }, 0);
    return this;
}

s.Page.prototype.scrollToFirst = function() {
    /*Scrolls to put the outermost passage at the top.

    Uses `Page.ready()` to check if the incoming passage corresponds to
    a node.

    Returns:
        Page: The calling `Page` instance.
    */
    this.ready();

    jQuery('html,body').animate({scrollTop:0},0);
    return this;
}

s.Page.prototype.embedPsg = function(node, time, nobreak) {
    /*Removes the current actions from the page, inserts the given node
    and its actions into the bottom of the page, scrolls to put the new
    content at the top, appends the page's list of embedded passages,
    and adds a new moment to SC's history. The embedded passage is
    preceded by a scene break ("****") unless the optional `nobreak`
    argument is true.

    The time parameter is a nonnegative integer that defaults to zero
    and sets the moment in history to use when parsing. See
    `Page.insertPsgText` for details.

    Uses `Page.ready()` to check if the incoming passage corresponds to
    a node.

    Args:
        node (Node): The node to embed.
        time (int, optional): A nonnegative integer that defaults to
            zero. Sets the moment in history to use when parsing.
        nobreak (bool, optional): Defaults to false. Set to true to omit
            the scene break.

    Returns:
        Page: The calling `Page` instance.

    Raises:
        Error: If trying to embed a passage into itself.
    */
    this.ready();

    var nodePsg = node.getPassage();
    if (nodePsg.title === passage() ||
        this._embeddedPsgs.indexOf(nodePsg.title) >= 0) {
        throw new Error(
            'Page.embedPsg():\n' +
            'cannot embed a passage in itself'
        );
    }

    var latestPsg = this.innerPsg();
    $('#' + latestPsg.domId + '-actions').empty();
    this.insertPsgText(nodePsg, latestPsg, time, nobreak);
    this.insertActions(nodePsg);
    this._embeddedPsgs.push(nodePsg.title);
    this._noBreakFlags.push(nobreak);
    this.scrollToLast();
    State.create(State.passage);
    Save.autosave.save();
    return this;
}

s.Page.prototype.load = function(node, embed, nobreak) {
    /*Checks the debug controller's cheat code and toggles debug mode if
    necessary, runs the given node's `onLoad` function, then renders the
    node's passage.

    If the optional parameter `embed` is true, then rather than
    rendering the passage, the passage's contents are appended to the
    end of the last embedded passage, the page is scrolled to put the
    new passage content at the top, and a new moment is added to SC's
    history. The appended content is preceded by a scene break ("****"),
    unless the optional `nobreak` parameter is true.

    If `node` is an info node or the current passage is not associated
    with a node, `embed` and `nobreak` have no effect.

    Args:
        node (Node): The node to load.
        embed (bool, optional): If `true`, the node's passage will be
            embedded in the currently loaded page. Defaults to the value
            of the calling `Page` instance's `_continuous` attribute.
        nobreak (bool, optional): Defaults to false. Set to true to omit
            the scene break when embedding.

    Returns:
        Page: The calling `Page` instance.
    */
    var code = s.debCon.getCheat();
    var L = code.length;
    if (
        code[L - 1] === node.getPassage().title &&
        State.length >= L &&
        code.slice(0, L - 1).every(function(psgTitle, i) {
            return code[i] === State.peek(L - 2 - i).title;
        })
    ) {
        s.debCon.toggle();
    }

    if (embed == null) {
        embed = this._continuous;
    }
    if (!this.ready(true) || node instanceof s.InfoNode) {
        embed = false;
    }

    node.onLoad();
    var nodePsg = node.getPassage();
    if (embed) {
        this.embedPsg(node, 0, nobreak);
    } else {
        this._embeddedPsgs = [];
        this._noBreakFlags = [];
        Engine.play(nodePsg.title);
    }
    return this;
}

st.page = new s.Page();
s.preProcText = [];

Config.passages.onProcess = function(p) {
    /*Performs all the necessary pre-processing on the passage text.
    Does nothing further if the current passage is not associated with a
    node.

    Rewinds variables to a previous moment to account for embedded
    passages. Variables will be restored on `:passagedisplay`. Then
    processes the node markup.

    Args:
        p (<<abbr SC Passage>>): The abbreviated SC Passage object
            representing the passage being processed.

    Returns:
        str: The processed text.
    */
    var text = p.text;
    for (var i = 0; i < s.preProcText.length; i++) {
        if (p.title === s.preProcText[i][0]) {
            text = s.preProcText[i][1](text);
        }
    }

    if (s.getNode(p.title) === undefined) {
        return text;
    }

    s.loadVars(st.page.length());
    var processedText = st.parser.procAllMarkup(p.title, text);
    return processedText;
};

s.onStoryReady = function() {
    /*Executes `st.page.scrollToLast()` upon browser refresh. Other,
    more straightforward attempts to code this failed. According to
    Akjosch in the Twine Games Discord server, "The 'problem' here is
    that the modern browsers don't bother to calculate the sizes of
    things which they don't have to render if they can help it, so while
    the structure is there, it's all kinda hidden and wishy-washy until
    the data-init value gets removed, which (via CSS rules) prompts the
    browser to recalculate all relevant sizes and positions. And then
    you can scroll."
    */
    if (!st.page.ready(true)) {
        return;
    }
    var observer = new MutationObserver(function(m) {
        for(var mut of m) {
            if(mut.type === "attributes" && mut.attributeName === "data-init") {
                st.page.scrollToLast();
                observer.disconnect();
            }
        }
    });
    
    observer.observe(document.scrollingElement, {attributes: true});
}

$(document).one(':storyready', s.onStoryReady);

s.onPsgDisplay = function(ev) {
    /*Triggered by the `:passagedisplay` event. First resets variables
    to the current time, to undo any changes made by
    `Config.passages.onProcess`. Then re-inserts embedded passage text
    one at a time. Finally, inserts actions and scrolls to the latest
    embedded passage. Does nothing if the current passage is not
    associated with a node.

    Args:
        ev (<<SC passagedisplay event obj>>): The event object passed to
            the  passagedisplay event handler.
    */
    if (s.getNode(ev.passage.title) === undefined) {
        return;
    }

    s.loadVars(0);

    var currentPsg = ev.passage;
    var nextPsg, time;
    for (var i = 0; i < st.page.length(); i++) {
        nextPsg = Story.get(st.page.getPsg(i));
        time = st.page.length() - (i + 1)
        st.page.insertPsgText(
            nextPsg, currentPsg, time, st.page.getFlag(i)
        );
        currentPsg = nextPsg;
    }

    st.page.insertActions(st.page.innerPsg());
    st.page.scrollToLast();
    return;
}

$(document).on(':passagedisplay', s.onPsgDisplay);

Config.passages.descriptions = function() {
    /*Provides a description of the `this` passage. If `this` is the
    outermost passage of the current page and the node associated with
    the innermost passage has a non-null `_excerpt` attribute, returns
    that attribute as the description. Otherwise, returns `null`,
    triggering SugarCube to use its default excerpt as the description.

    (SC's `Passage.description()` returns the passage object's
    `_excerpt` attribute, if that attribute is not null. See
    https://github.com/tmedwards/sugarcube-2/blob/
    7e13f2665c2df989ccd498d2d7162f58b9392192/src/passage.js#L145)

    Returns:
        str or null: The passage description, if the given passage is
        the current passage and the inner node's `_excerpt` attribute is
        non-null; otherwise, null.
    */
    if (this.title !== passage()) {
        return null;
    }
    var psg = st.page.innerPsg();
    return s.nodes.get(psg).getExcerpt();
}
/* twine-user-script #13: "0125-DirectedOutcome.js" */
/*Uses: Page_.

Builds the `DirectedOutcome` class.

*/

s.DirectedOutcome = function(node, func, embed, nobreak) {
    /*An outcome with a node that is loaded at the end.

    Args:
        node (Node): Assigned to the `_targetNode` attribute.
        func (func, optional): Assigned to the `_userScript`
            attribute. Defaults to a function that does nothing.
        embed (bool or null, optional): Assigned to the `_embed`
            attribute. Defaults to null.
        nobreak (bool or null, optional): Assigned to the `_nobreak`
            attribute. Defaults to null.

    Attributes:
        _userScript (func): The function to call when the outcome is
            carried out. Should take no parameters.
        _targetNode (Node): The node to load after carrying out the
            outcome.
        _embed (bool or null): Passed as a parameter to `Page.load()`
            when loading the target node.
        _nobreak (bool or null): Passed as a parameter to `Page.load()`
            when loading the target node.

    */

    s.Outcome.call(this, func);
    this._targetNode = node;
    if (embed === undefined) {
        this._embed = null;
    } else {
        this._embed = embed;
    }
    if (nobreak === undefined) {
        this._nobreak = null;
    } else {
        this._nobreak = embed;
    }
    return this;
};

s.DirectedOutcome.prototype = Object.create(s.Outcome.prototype);

Object.defineProperty(s.DirectedOutcome.prototype, 'constructor', {
    value: s.DirectedOutcome,
    enumerable: false,
    writable: true
});

s.DirectedOutcome.prototype.carryOut = function() {
    /*(override) Carries out `_userScript` if it is not `null`, then
    loads `_targetNode` with the `_embed` and `_nobreak` options.
    */
    if (this._userScript != null) {
        this._userScript();
    }
    st.page.load(this._targetNode, this._embed, this._nobreak);
}

s.DirectedOutcome.prototype.setEmbed = function(embed, nobreak) {
    /*Sets the `_embed` and `_nobreak` attributes.

    Args:
        embed (bool): Assigned to the `_embed` attribute.
        nobreak (bool, optional): Assigned to the `_nobreak` attribute.
            Defaults to null.

    Returns:
        DirectedOutcome: The calling instance.
    */
    this._embed = embed;
    if (nobreak === undefined) {
        this._nobreak = null;
    } else {
        this._nobreak = nobreak;
    }
    return this;
}
/* twine-user-script #14: "0130-Menu_.js" */
/*Uses: SavesManager_, ActionList, Page_.

Builds and instantiates the `Menu` class. Removes the default 'Saves'
and 'Restart' buttons from SC's UI bar, since the menu object will
provide its own. Adds preprocessing arrays to `s.preProcText` from
`Page_.js` which write the menu to SC's UI bar, the header, and the
'Start' passage. A 'no-menu' tag on a passage will prevent the writing
of the menu.

Attributes:
    s.menu (Menu): A `Menu` instance for use by other classes.

*/

s.Menu = function() {
    /*The in-game menu offering persistent actions to the user.

    A `Menu` object is an `ActionList` with built-in 'begin', 'resume',
    'save', 'load', and 'restart' actions. The 'save', 'load', and
    'restart' methods are kept at the end of the list. These actions are
    automatically inserted into various areas of the story (such as the
    header, the UI bar, and the bottom of the 'Start' passage.)

    Attributes:
        _array (arr): The embedded array of `Action` objects.
        _fixedEnd (int): Indicates how many elements at the end of the
            array to keep fixed in place. Defaults to 3.

    */
    
    s.ActionList.call(this, 3);
    this.addAction(
        'restart',
        function() {
            if (ss.debugOn || confirm('Really restart?')) {
                Save.clear();
                if (passage() === 'Start') {
                    memorize('autoStart', true);
                }
                Engine.restart();
            }
        },
        function() {
            return (
                passage() !== 'Start' ||
                Save.autosave.has()
            );
        }
    );
    this.addAction(
        'load',
        function() {
            if (Save.slots.isEmpty()) {
                alert("No bookmark to load.");
            } else {
                UI.saves();
            }
        },
        Config.saves.isAllowed
    );
    this.addAction(
        'save',
        function() {
            s.savesMgr.saveBkMark();
        },
        Config.saves.isAllowed
    );
    this.addAction(
        'begin',
        function() {
            st.page.load(s.root);
        },
        function() {
            return (
                passage() === 'Start' &&
                !Save.autosave.has()
            );
        }
    );
    this.addAction(
        'resume',
        function() {
            s.savesMgr.load(0);
        },
        function() {
            return (
                passage() === 'Start' &&
                Save.autosave.has()
            );
        }
    );
    return this;
};

s.Menu.prototype = Object.create(s.ActionList.prototype);

Object.defineProperty(s.Menu.prototype, 'constructor', {
    value: s.Menu,
    enumerable: false,
    writable: true
});

s.Menu.prototype.addAction = function(text, carryOutFunc, checkFunc, index) {
    /*(override) This method is for adding a simple action with one
    outcome to the menu.

    Args:
        text (str): The display text of the action.
        carryOutFunc (func, optional): The function to be executed when
            the action is taken. Defaults to a function that does
            nothing.
        checkFunc (func or bool, optional): Used to determine whether
            the action should be displayed. Defaults to a function that
            returns `true` if the current passage is not the 'Start'
            passage.
        index (int, optional): Where in the embedded array the new
            action should be inserted. Defaults to the end of the array.

    Returns:
        Menu: The calling instance.
    */
    if (checkFunc == null) {
        checkFunc = function() {
            return (passage() !== 'Start');
        }
    }
    return s.ActionList.prototype.addAction.call(
        this, text, carryOutFunc, checkFunc, index
    );
}

s.Menu.prototype.addInfoNode = function(text, psgTitle) {
    /*Adds a link to an info node. If the given passage title is not
    associated to a node, an info node is created and associated with
    it.

    Args:
        text (str): The text of the link.
        psgTitle (str): The title of the info node passage to link to.

    Returns:
        Menu: The calling instance.

    Raises:
        Error: If the given passage title is associated to a node that
            is not an info node.
    */
    var node = s.getNode(psgTitle);
    if (node === undefined) {
        node = new s.InfoNode(psgTitle);
    } else if (!(node instanceof s.InfoNode)) {
        throw new Error(
            'Menu.addInfoNode():\n' +
            psgTitle + ' is not an info node'
        );
    }
    this.addAction(text, function() {
        st.page.load(s.getNode(psgTitle));
    });
    return this;
}

s.menu = new s.Menu();
$('#menu-item-restart').remove()
$('#menu-item-saves').remove()

s.autoStart = function() {
    /*Check and carry out the 'begin' action.
    */
    var begin = s.menu.getAction('begin');
    if (begin.check()) {
        begin.choose().carryOut();
    }
}

s.menuMarkup = function() {
    /*Processes the menu actions to create SC markup.

    Returns:
        str: SC markup for menu links.
    */
    var text = '';
    var action;
    for (var i = 0; i < s.menu.length(); i++) {
        action = s.menu.get(i);
        if (!action.check()) {
            continue;
        }
        if (text !== '') {
            text += ' / ';
        }
        text += (
            '<<link "' + action.getText() + '">>' +
                '<<run s.menu.get(' + i + ').choose().carryOut()>>' +
            '<</link>>'
        );
    }
    return text;
}

s.preProcText.push(['StoryMenu', function(text) {
    /*Adds the menu to the UI bar if it is visible and the current
    passage allows the menu.

    Args:
        text (str): The passage text to process.

    Returns:
        str: The processed text.
    */
    if (!UIBar.isHidden() && !tags().includes('no-menu')) {
        return s.menuMarkup();
    } else {
        return '';
    }
}]);

s.preProcText.push(['PassageHeader', function(text) {
    /*Adds the menu to the header with the sticky class if the current
    passage allows it, unless currently at the Start passage. Otherwise,
    adds a line break to compensate for the reduced upper margin (needed
    to have the sticky class work as intended).

    Args:
        text (str): The passage text to process.

    Returns:
        str: The processed text.
    */
    var buttonMarkup = (
        '<span title="Scroll to top">' +
            '<<button &uarr;>>' +
                '<<run st.page.scrollToFirst()>>' +
            '<</button>>' +
        '</span>' +
        '<span title="Scroll to bottom">' +
            '<<button &darr;>>' +
                '<<run st.page.scrollToLast()>>' +
            '<</button>>' +
        '</span>'
    );

    return (
        '<<if !tags().includes("no-menu") && passage() !== "Start">>' +
            '<div id="header" class="sticky"><br>' +
                s.menuMarkup() +
                '<span style="float:right;">' +
                    buttonMarkup +
                '</span><br><hr>' +
            '</div>' +
        '<<else>>' +
            '<br>' +
        '<</if>>'
    );
}]);

s.preProcText.push(['Start', function(text) {
    /*Use the autoStart metadata from the restart action to skip the
    title page.

    Args:
        text (str): The passage text to process.

    Returns:
        str: The processed text.
    */
    return (
        '<<timed 0s>>' +
            '<<if ss.debugOn || recall("autoStart", false)>>' +
                '<<run forget("autoStart")>>' +
                '<<run s.autoStart()>>' +
            '<</if>>' +
        '<</timed>>' +
        text
    );
}])

s.preProcText.push(['Start', function(text) {
    /*Adds the menu to the bottom of the Start passage.

    Args:
        text (str): The passage text to process.

    Returns:
        str: The processed text.
    */
    return (
        text + '<br>' +
        '<div style="text-align:center">' +
            s.menuMarkup() +
        '</div>'
    );
}]);
/* twine-user-script #15: "0140-Path_.js" */
/*Uses: standard.

Builds and instantiates the `Path` class.

Attributes:
    st.path (Path): A `Path` instance for use by other classes.

*/

s.Path = function() {
    /*Tracks and manages the history of choices and outcomes.

    There is one instance (`st.path`), built in State.variables, so
    its state can be stored in SugarCube's history. The class must
    therefore be made compatible with SugarCube by having `clone ()` and
    `toJSON()` methods, and no recursive objects or object sharing. To
    achieve this, we also require it to have a constructor with no
    arguments and to have all its attributes be SC supported types.
    
    Attributes:
        _nodeLengths (arr of int): The lengths of the nodes visited so
            far. Recall that the length of a node is the number of
            actions it contains.
        _axnChoices (arr of int): Lists the index of the action chosen
            at each node.
        _axnLengths (arr of int): The lengths of the actions chosen so
            far. Recall that the length of an action is the number of
            outcomes it contains.
        _outcomes (arr of int): Lists the index of the outcome that
            resulted from each choice.

    */
    
    this._nodeLengths = [];
    this._axnChoices = [];
    this._axnLengths = [];
    this._outcomes = [];
}

s.Path.prototype._init = function(obj) {
    /* Needed for SugarCube compatibility. */
    Object.keys(obj).forEach(function (pn) {
        this[pn] = clone(obj[pn]);
    }, this);
    return this;
};

s.Path.prototype.clone = function () {
    /* Needed for SugarCube compatibility. */
    return (new s.Path())._init(this);
};

s.Path.prototype.toJSON = function () {
    /* Needed for SugarCube compatibility. */
    var newPC = {};
    Object.keys(this).forEach(function (pn) {
        newPC[pn] = clone(this[pn]);
    }, this);
    return JSON.reviveWrapper(
        '(new s.Path())._init($ReviveData$)', newPC
    );
};

s.Path.prototype.addEdge = function(
        numActions, actionIndex, numOutcomes, outcomeIndex
    ) {
    /*Adds a new "edge" to the path. That is, adds a new element to each
    of the embedded arrays. Called when the player takes an action.

    Args:
        numActions (int): The length of the node from which the player
            selected an action.
        actionIndex (int): The index of the action the player took.
        numOutcomes (int): The length of the action the player took.
        outcomeIndex (int): The index of the outcome that resulted from
            the player's selected action.

    Returns:
        Path: The calling instance.
    */
    this._nodeLengths.push(numActions);
    this._axnChoices.push(actionIndex);
    this._axnLengths.push(numOutcomes);
    this._outcomes.push(outcomeIndex);
    return this;
}

s.Path.prototype.view = function() {
    /*Displays the path in the console.
    */
    var pathStr = '';
    for (var i = 0; i < this._nodeLengths.length; i++) {
        pathStr += (
            'took action ' +
            (this._axnChoices[i]+1) + ' of ' + this._nodeLengths[i] +
            '; got outcome ' +
            (this._outcomes[i]+1) + ' of ' + this._axnLengths[i] + '\n'
        );
    }
    console.log(pathStr);
}

st.path = new s.Path();
/* twine-user-script #16: "8000-functions.js" */
/*Uses: Page_.

Defines a collection of useful functions for designing a story with the
node system.

*/

s.getAction = function(actionPsg, actionText) {
    /*Get an `Action` object.

    Args:
        actionPsg (str): The title of the passage containing the action.
        actionText (str): The text of the action to get.

    Returns:
        Action: The action object determined by the arguments.
    */
    return s.getNode(actionPsg).getAction(actionText);
}

s.addLink = function(startPsg, text, func, targetPsg, checkFunc) {
    /*Creates a link (i.e. an action with a single Directed Outcome) in
    the node associated with the given passage title.

    Args:
        startPsg (str): The title of the passage on which to create
            the link. If this passage is not associated to a node, a
            new node will be created and associated with it.
        text (str): The text of the link.
        func (func or null): If not null, this function will be carried
            out just prior to loading the node associated with
            `targetPsg`.
        targetPsg (str): The passage title of the node the link will
            load. If the passage title is not associated with a node, a
            node will be created.
        checkFunc (func or bool, optional): Used to determine whether
            the link should be displayed. Defaults to `true`.
    */
    var startNode = s.getNode(startPsg);
    if (startNode === undefined) {
        startNode = new s.Node(startPsg);
    }

    var action = new s.Action(text, checkFunc);

    startNode.push(action);

    var targetNode = s.getNode(targetPsg);
    if (targetNode === undefined) {
        targetNode = new s.Node(targetPsg);
    }

    var outcome = new s.DirectedOutcome(targetNode, func);

    action.push(outcome);

    return outcome;
}

s.setSubCount = function(psgTitle, num) {
    /*Sets the sub count of the node associated with the given passage
    title. If no such node exists, one is created. Returns the
    associated node.

    Args:
        psgTitle (str): A passage title.
        num (int): The number of sub counts to assign to the passage's
            node.

    Returns:
        Node: The node, after its sub count is set.
    */
    var node = s.getNode(psgTitle);
    if (node === undefined) {
        node = new s.Node(psgTitle, num);
        return node;
    } else {
        return node.setSubCount(num);
    }
}

s.copyActions = function(fromPsgTitle, toPsgTitle) {
    /*Copies actions from one node to another.

    Args:
        fromPsgTitle (str): The title of the passage associated with the
            node whose actions are to be copied.
        toPsgTitle (str): The title of the passage associated with the
            node into which the copied actions are to be inserted.
    */
    var fromNode = s.getNode(fromPsgTitle);
    var toNode = s.getNode(toPsgTitle);
    for (var i = 0; i < fromNode.length(); i++) {
        toNode.push(fromNode.get(i));
    }
    return;
}
/* twine-user-script #17: "9000-main.js" */
/* Builds the node structure for the game. Nodes, Actions, and Outcomes
should never be created dynamically. They should all be constructed
here, prior to the start of play. Use an Action's check function to hide
or show possible actions, depending on conditions. Use an Actions's
choose function to select between different possible outcomes, depending
on conditions.
*/

s.version.set(0,5,5);
s.savesMgr.setBlock(true); // block loading of saves from old versions
s.savesMgr.setBkMarks(8); // allow 8 bookmarks instead of 1
st.page.setContinuous(true); // make embedding passages the default

// build menu
s.menu.addInfoNode('info', 'help');
s.menu.addInfoNode('bio', 'bio');

// set cheat code for debug mode
s.debCon.setCheat([
    'help', 'help', 'help', 'bio', 'help', 'bio', 'help', 'help', 'bio'
]);

// make initial links
s.addLink('Root', 'continue', null, 'RNG warning');
s.addLink(
    'RNG warning', 'got it', null, 'who you are', null
).setEmbed(false); // don't embed
s.addLink('who you are', 'take a look around', null, 'bedroom');

// bedroom actions

    // take the knife
    s.addLink(
        'bedroom',
        'take the knife',
        function() {
            // carry out
            v.containedIn.delete('knife');
            v.inventory.add('knife');
        },
        'Taking knife',
        function() {
            // check
            return (v.containedIn.get('knife') === 'bedroom');
        }
    ).setEmbed(true, true); // embed without scene break

    // search the body
    s.setSubCount('Cops bust in', 2);
    s.addLink(
        'bedroom',
        'search the body',
        function() {
            // carry out
            v.body.searched = true;
            v.pounding = false;
            st.parser.setSubs(
                'Cops bust in',
                [
                    '',

                    'As you bend down to take a closer look at the body, ' +
                    'the bedroom door bursts open. '
                ]
            );
        },
        'Cops bust in',
        function() {
            // check
            return !v.body.searched;
        }
    );
    s.getAction('bedroom', 'search the body').addOutcome(
        null,
        'Cat involved',
        'random'
    );

    // s.addLink('bedroom', 'mark body as searched', null, function() {
    //     v.body.searched = true;
    //     State.create(State.passage);
    //     st.page.refreshActions();
    // }, function() {
    //     return !v.body.searched;
    // });

    // s.addLink('bedroom', 'mark body as not searched', null, function() {
    //     v.body.searched = false;
    //     State.create(State.passage);
    //     st.page.refreshActions();
    // }, function() {
    //     return v.body.searched;
    // });

// Taking knife actions
s.copyActions('bedroom', 'Taking knife');

// Cops bust in actions
s.addLink('Cops bust in', 'continue', null, 'Next');
/* twine-user-script #18: "Story JavaScript" */


:: StorySubtitle
Story Subtitle


:: StoryAuthor
Story Author


:: StoryDisplayTitle
Story Display Title


:: StoryBanner
Story Banner


:: StoryCaption
Story Caption


:: StoryMenu
/* This passage needs to be here and should be empty */


:: StoryInit
<<set $pounding = true>>
<<set $crowbar = false>>
<<set $knowledge = new Set()>>
<<set $containedIn = new Map()>>
<<run $containedIn.set("knife", "bedroom")>>
<<set $body = {
    searched: false
}>>
<<set $detective = {
    discovered: false
}>>
<<set $inventory = new Set()>>


:: PassageHeader
/* This passage needs to be here and should be empty */


:: help
<p>The story you are reading is a work of interactive fiction. In interactive fiction you play the main character of a story. Your actions drive the story forward.</p>

<p>In this story, you control the character by tapping (or clicking) on links. Tap a noun to examine that object in closer detail. Tap a command to follow that action. Tapping a noun will usually not advance the story. Tapping a command, though, is often irreversible.</p>

<p><b class="headings">Random outcomes.</b> Some actions may have a random outcome which could be good or bad. Your chances of getting a good outcome are related to your character's traits. Click on "view Character Sheet" in the footer to better understand these traits. The Character Sheet also shows what you are carrying, what you have learned, and any injuries you may have suffered.</p>

<p><b class="headings">Saving.</b> The story automatically saves your progress, so if you exit and reload later, you will be able to resume right where you left off. You can also manually save your progress in a bookmark that can be reloaded later. But think carefully about this. You only get one bookmark! (Warning: using private browsing or disabling or clearing your cookies will interfere with the story's saving feature.)</p>


:: bio
<p>This screen holds information about your character.</p>


:: Start
/* Cannot be used as a node; should not have branching choices. */
<div style='text-align:center'>
    <h1><<= Story.title>></h1>
    by<br>
    <<= Story.get('StoryAuthor').text>><br>
    version <<= s.version.asString()>><br>
    <br>
    <br>
    <br>
</div>


:: Root [no-menu]
/* The 'Root' passage must be present. It will be the first passage
visited after the `Start` passage.
*/
<p>It started with one shot of whiskey. Of course, most nights started with one shot of whiskey. Then one became two and two became more. Before long, you were making a fool of yourself. At least you assume you were. You can't remember.</p>

<p>That was last night. This morning, you wake up alone on a strange bed in a house you've never seen before. From the trash and bottles lying around, this had to be the scene of some after-party. But where is everyone? And what is that smell? It's then you realize your clothes are covered in blood.</p>

<p>When you get out of the bed, you see it. The body. A man lying on his back, dead, with a knife sticking out of his chest. Before you can do or think anything, someone starts pounding on the front door. Is it the police? Is it the murderer? Are //you// the murderer?</p>


:: RNG warning [no-menu]
<p>In this story, your choices can have random consequences. The chances of the various outcomes are affected by your character's traits. You can read about those traits on the Character Sheet. The Character Sheet also shows what you are carrying, what you have learned, and any injuries you may have suffered.</p>


:: who you are
<p>Scott Allen Brady. Scotty, to your friends. That's your name. You have to remind yourself, just to make sure you haven't forgotten //everything//. The last thing you remember is leaving work. You'd finished packing the motherboards into their shipping crates. Then you clocked out and left the plant. You were still wearing your Hewlett-Packard shirt when you got in your truck. You met some friends at the bar. Then...</p>

<p>Nothing. You can't remember. Now here you are, in some surreal nightmare, looking at a dead guy. The pounding on the door makes it hard to concentrate.</p>


:: bedroom
<p>You are in what has to be the master bedroom. You reek of alcohol, your mouth is dry and tastes like vomit, and your head is throbbing. There's blood on your clothes, in your hair, and on your face and hands. You've had better days.</p>

<p>You're wearing a white T-shirt with the Seattle Seahawks logo on the front. But you can hardly see the logo under all the blood. Your jeans are also caked with dried blood.</p>

<p>On your left, the {bedroom door|A} is closed. <<if $pounding>>You can hear the pounding on the front door coming from that direction. <<elseif $crowbar>>Outside the bedroom, <<if $knowledge.has("policeAtDoor")>>the police are<<else>>someone is<</if>> breaking into the house with a crowbar. <</if>>To your right, the {door|B} to the adjoining bathroom is ajar. On the floor is a {dead man|C}, lying on his back in a pool of blood. <<if $containedIn.get("knife") == "bedroom">>What looks like a heavy-duty {chef's knife|D} is sticking out of his chest.<</if>></p>

{?A|<p>The bedroom door is white, like the walls of the room. Blood is spattered on the left side near the door handle.</p>}

{?B|<p>The bathroom door is made of cheap plywood and won't even close all the way.</p>}

{?C|<p>You've never seen the dead man before, as far as you can remember. He must be in his mid-thirties.</p>}

{?D|<p>The murder weapon looks like the kind of knife they have hanging on the wall in a restaurant kitchen--the kind they use to cut meat or chop big vegetables. It has a wide blade and is about a foot long.</p>}


:: Cops bust in
<p>{0}</p>

<p>{1}Three men rush in. "Get down on the ground!" one shouts. <<if $inventory.has("knife")>>"He's got a knife!" yells another.<</if>> They all have their guns trained on you. The bald man in the center looks like a police {detective|A}. The other two are uniformed cops.</p>

{?A|The detective doesn't move. He doesn't blink. He just stands there scowling, waiting for you to make a move.}


:: Cat involved
<p>You can see scratches on the neck of the victim, like from a small animal. //A cat?// you wonder. There are more scratches on his hands and wrists. Looking closer, you see fur on his collar and sleeves. Glancing around the room, though, you see no trace of a cat.</p>


:: Taking knife
<p>You take the knife and carefully slide it under your belt. You may need this for later.</p>


:: Next
To be continued.


