:: StoryTitle
Story Title


:: StoryData
{
	"ifid": "5406BF44-CF93-41CF-9DED-9824A52E2F82",
	"format": "SugarCube",
	"format-version": "2.31.1",
	"start": "Start",
	"zoom": 1
}


:: Story Stylesheet [stylesheet]
/* twine-user-stylesheet #1: "main.css" */
html {
    font: 100% Georgia, serif;
}
body {
    color: white;
    background-color: black;
}
a {
    cursor: pointer;
    color: #68d;
    text-decoration: none;
    font-weight: bold;
    transition-duration: 200ms;
}
.description {
    /* Detailed description information revealed when clicking a noun. */
    color: yellow;
}
.headings {
    /* Headings in help page. */
    color: lime;
}
.sticky{
    /* Makes the header stick to the top of the screen. This is handled automatically by the `onProcess` function in `rendering.js`. */
    position: sticky;
    position: -webkit-sticky;
    top: 0;
    left: 0;
    width: 100%;
    z-index: 49;
    background-color: black;
}
#story {
    /* Removes the top margin, so the header sticks seamlessly. Line breaks should be added manually at the top of the header and any passage with a `no-header` tag. This is handled automatically by the `onProcess` function in `rendering.js`. */
    margin-top: 0px;
}
/* twine-user-stylesheet #2: "Story Stylesheet" */


:: Story JavaScript [script]
/* twine-user-script #1: "0010-standard.js" */
/*
Establishes shorthand aliases for commonly used namespaces, and sets
other basic properties.
*/

Object.defineProperty(window, "s", {
    get: function() {
        return setup;
    }
});

Object.defineProperty(window, "ss", {
    get: function() {
        return settings;
    }
});

Object.defineProperty(window, "v", {
    get: function() {
        return State.variables;
    }
});

Object.defineProperty(window, "t", {
    get: function() {
        return State.temporary;
    }
});

v.static = {}; // We will occasionally make temporary journeys in time
               // via SC's history. This namespace is for variables that
               // should be unaffected by those journeys.

Object.defineProperty(window, "st", {
    get: function() {
        return State.variables.static;
    }
});

s.loadVars = function(time) {
    // Replaces `v` with a copy of `State.variables` from the moment
    // with index `time`. Does not touch `v.static`.
    //
    // @param {Integer} time - A nonpositive integer representing the
    // time from which to take the variable data. A value of 0 denotes
    // the present.
    var oldVars = State.peek(-time).variables;
    Object.keys(v).forEach(function(pn) {
        if (pn !== 'static') {
            delete v[pn];
        }
    });
    Object.keys(oldVars).forEach(function(pn) {
        if (pn !== 'static') {
            v[pn] = clone(oldVars[pn]);
        }
    });
    return;
}

Config.passages.nobr = true; // sets all passages to `nobr`

window.onerror = function(msg, url, linenumber) {
    /*
    Ensures that errors appear in a pop-up for greater visibility. Works
    in Firefox, but doesn't seem to work in Safari. Be sure to do
    testing in Firefox.
    */
    alert(
        'Error message: ' + msg + '\n' +
        'URL: ' + url + '\n' +
        'Line Number: ' + linenumber
    );
    return true;
}

Config.saves.autosave = true; // turn on autosave feature

s.autosave = {
    sufficient: [], // array of Boolean-valued functions giving
                    // sufficient conditions to allow autosaving
    necessary: []   // array of Boolean-valued functions giving
                    // necessary conditions to allow autosaving
}

Config.saves.isAllowed = function () {
    var i;
    for (i = 0; i < s.autosave.sufficient.length; i++) {
        // passing any sufficient check allows the save
        if (!s.autosave.sufficient[i]()) {
            continue;
        }
        return true;
    }
    for (i = 0; i < s.autosave.necessary.length; i++) {
        // failing any necessary check prevents the save
        if (s.autosave.necessary[i]()) {
            continue;
        }
        return false;
    }
    return true; // otherwise defaults to true
};

s.autosave.necessary.push(function() {
    // do not autosave at the 'Start' passage
    return (passage() !== 'Start');
});
/* twine-user-script #2: "0020-Outcome.js" */
// standard

s.Outcome = function(func) {
    /*
    Represents one possible result of a player action.

    @param {Function} func - The function to call when the outcome is
    carried out.
    */
    this._userScript = func;
    return this;
}

s.Outcome.prototype.carryOut = function() {
    if (this._userScript == null) {
        return;
    } else {
        return this._userScript();    
    }
}
/* twine-user-script #3: "0030-List.js" */
// standard

s.List = function(fixedEnd) {
    /*
    A wrapper around an array with methods for controlling manipulation
    and access of elements.

    @param {Boolean} fixedEnd - Defaults to false. If true, the `push`
    method will keep the last element is _array in the last position.
    */
    this._array = [];
    if (fixedEnd === undefined) {
        this._fixedEnd = false;
    } else {
        this._fixedEnd = fixedEnd;
    }
    return this;
}

s.List.prototype._verify = function(obj) {
    /*
    Checks if `obj` qualifies to be in the list. Should be overwritten
    by subclasses.
    */
    return true;
}

s.List.prototype.insert = function(index, obj) {
    /*
    If the object passes the `_verify` test, inserts it at index. (E.g.,
    an index of 0 inserts it at the beginning, and index equal to the
    length of _array inserts it at the end.)

    If you try to insert to the end of the list when _fixedEnd is true,
    will insert to the second to the last spot.
    */
    if (this._verify(obj)) {
        if (index === this._array.length && index > 0 && this._fixedEnd) {
            index -= 1;
        }
        this._array.splice(index, 0, obj);
    } else {
        throw new Error(
            'List.insert():\n' +
            'object does not qualify for list'
        );
    }
    return this;
}

s.List.prototype.push = function() {
    /*
    Takes any number of objects as parameters. If any given object
    fails the `_verify` test, throws an error. Otherwise, adds all
    objects to `_array` and returns the calling `List` object.
    */
    if (arguments.length > 0) {
        var args = Array.prototype.slice.call(arguments);
        var arg = args.shift();
        this.insert(this._array.length, arg);
        this.push.apply(this, args);
    }
    return this;
}

s.List.prototype.delete = function(index) {
    /*
    Deletes the list element at the given index and returns the modified
    `List` object. Throws an error if index is out of range. Returns the
    calling `List` object.
    */
    if (index !== parseInt(index, 10) || index < 0 ||
        index >= this._array.length) {
        throw new Error(
            'List.delete():\n' +
            'invalid index'
        );
    }
    this._array.splice(index, 1);
    return this;
}

s.List.prototype.get = function(index) {
    return this._array[index];
}

s.List.prototype.indexOf = function(obj) {
    return this._array.indexOf(obj);
}

s.List.prototype.length = function() {
    return this._array.length;
}
/* twine-user-script #4: "0040-Action.js" */
// List

s.Action = function(text, checkFunc, chooseFunc) {
    /*
    In a given passage, the reader will choose from a list of actions.
    Each action can be displayed as a link, and when it is selected,
    the story will choose from a list of that action's possible
    outcomes. An `Action` object represents one of these actions.

    Structurally, an action object is a list of outcomes with a display
    text for the link, and some additional methods available. As such,
    it is implemented as a subclass of `List`.

    @param {String} text - The text to appear in the link.
    @param {Function|Boolean} checkFunc (optional) - The function to
    call when checking if the action should be displayed. Should return
    a boolean. If a boolean is provided, simply returns that boolean.
    Defaults to true.
    @param {Function} chooseFunc (optional) - The function to call when
    choosing an outcome. Should return an outcome from the action. If
    not provided, the first outcome in the list will be chosen.
    @param {String} align (optional) - The CSS text-align value for the
    link associated with this action. Defaults to 'left'.
    */
    s.List.call(this);
    this._displayText = text;

    if (checkFunc == null)  {
        this._userScriptCheck = true;
    } else {
        this._userScriptCheck = checkFunc;
    }

    this._userScriptChoose = chooseFunc || function() {
        return this._array[0];
    }
    this._align = 'left';
    return this;
};

s.Action.prototype = Object.create(s.List.prototype);

Object.defineProperty(s.Action.prototype, 'constructor', {
    value: s.Action,
    enumerable: false,
    writable: true
});

s.Action.prototype._verify = function(obj) {
    /*
    @override

    Members of an `Action` must be Outcome objects.
    */
    return (obj instanceof s.Outcome);
}

s.Action.prototype.getText = function() {
    return this._displayText;
}

s.Action.prototype.getAlign = function() {
    return this._align;
}

s.Action.prototype.setAlign = function(align) {
    this._align = align;
    return this;
}

s.Action.prototype.check = function() {
    if (typeof(this._userScriptCheck) === 'boolean') {
        return this._userScriptCheck;
    } else {
        return this._userScriptCheck();
    }
}

s.Action.prototype.choose = function() {
    if (this.length() === 0) {
        return null;
    } else {
        return this._userScriptChoose();
    }
}
/* twine-user-script #5: "0050-ActionList.js" */
// List, Action

s.ActionList = function(fixedEnd) {
    /*
    Action List is a subclass of List whose instance can contain only
    actions.
    */
    s.List.call(this, fixedEnd);
    return this;
};

s.ActionList.prototype = Object.create(s.List.prototype);

Object.defineProperty(s.ActionList.prototype, 'constructor', {
    value: s.ActionList,
    enumerable: false,
    writable: true
});

s.ActionList.prototype._verify = function(obj) {
    /*
    @override
    */
    return (obj instanceof s.Action);
}

s.ActionList.prototype.addAction = function(
    text, carryOutFunc, checkFunc, index
) {
    /*
    This method is for adding a simple action with one outcome to the
    list. It creates an outcome that executes `carryOutFunc`, adds it as
    the single outcome to a new action with link text `text` and check
    function `checkFunc`. The `checkFunc` parameter defaults to true.

    If an `index` parameter is given, will insert the action at the
    given index, otherwise will push the action.
    */
    if (index == null) {
        index = this.length();
    }
    var outcome = new s.Outcome(carryOutFunc);
    var action = new s.Action(text, checkFunc);
    action.push(outcome);
    this.insert(index, action);
    return this;
}

s.ActionList.prototype.getAction = function(actionText) {
    /*
    Returns the action from the list whose display text matches the
    given `actionText`. If no such action exists, returns null.
    */
    var action;
    for (var i = 0; i < this.length(); i++) {
        action = this.get(i);
        if (action.getText() === actionText) {
            return action;
        }
    }
    return null;
}
/* twine-user-script #6: "0060-Node_.js" */
// ActionList

s.nodes = new Map(); // maps SugarCube `Passage` objects to associated
                     // `Node` objects

s.getNode = function(psgTitle) {
    /*
    Returns the Node object associate with the passage titled,
    `psgTitle`.
    */
    return s.nodes.get(Story.get(psgTitle));
}

s.specialPsgs = [
    'PassageDone', 'PassageFooter', 'PassageHeader', 'PassageReady', 'Start', 
    'StoryAuthor', 'StoryBanner', 'StoryCaption', 'StoryDisplayTitle',
    'StoryInit', 'StoryInterface', 'StoryMenu', 'StorySettings', 'StoryShare',
    'StorySubtitle', 'StoryTitle'
];

s.Node = function(psgTitle, subCount, func, outOfChar) {
    /*
    A `Node` object is like a wrapper around a passage. It contains the
    passage which holds the narrative description of the situation, as
    well as a list of possible actions for the reader to choose from.

    Structurally, a node is a list of actions with a passage for the
    narrative description, and some additional methods. As such, it is
    implemented as a subclass of `ActionList`.

    The associated passage may have slots available for dynamically
    generated text substitutions. The node object has properties and
    methods for managing this. The `subCount` property should match the
    number of available text substitutions. It is there for a redundancy
    check to prevent the error of sending the wrong number of text
    substitutions when loading a node.

    Node objects, and their associated Action and Outcome objects,
    should be built on `s` so they are not stored in the player's local
    storage. As such, they will not be saved from session to session, so
    they should not be changed dynamically during gameplay.

    @param {String} psgTitle - The title of the associated passage.
    @param {Integer} subCount - The number of expected text
    substitutions. Defaults to 0.
    @param {Function} func (optional) - The function to call when the
    node is loaded. It runs immediately before the loading of the
    passage associated with the calling node. By default, it does
    nothing.
    @param {Boolean} outOfChar (optional) - True if the node content
    lies outside the narrative of the story (help screen, character
    stats, etc.) Defaults to false.

    @property passage - The SugarCube `Passage` object whose title is
    `psgTitle`
    */
    s.ActionList.call(this);
    if (!Story.has(psgTitle)) {
        throw new Error(
            'Node():\n' +
            'there is no passage titled "' + psgTitle + '"'
        );
    }
    if (s.specialPsgs.indexOf(psgTitle) >= 0) {
        throw new Error(
            'Node():\n' +
            'cannot assign a special passage to a node'
        );
    }
    var psg = Story.get(psgTitle);
    if (s.nodes.has(psg)) {
        throw new Error(
            'Node():\n' +
            'the passage "' + psgTitle + '" already belongs to a node'
        );
    }
    this._passage = psg;
    s.nodes.set(psg, this);
    this._subCount = subCount || 0;
    this._userScript = func;
    this._outOfChar = (outOfChar === undefined) ? false : outOfChar;
    return this;
};

s.Node.prototype = Object.create(s.ActionList.prototype);

Object.defineProperty(s.Node.prototype, 'constructor', {
    value: s.Node,
    enumerable: false,
    writable: true
});

s.Node.prototype.getPassage = function() {
    return this._passage;
}

s.Node.prototype.getSubCount = function() {
    return this._subCount;
}

s.Node.prototype.setSubCount = function(num) {
    /*
    Sets the sub count. Can only change it from its default value of 0
    one time, to prevent unwanted errors. Sub counts are not meant to
    dynamically change.
    */
    if (this._subCount !== 0) {
        throw new Error(
            'Node.setSubCount():\n' +
            'can only set sub count once'
        );
    }
    this._subCount = num;
    return this;
}

s.Node.prototype.onLoad = function() {
    if (this._userScript == null) {
        return;
    } else {
        return this._userScript();
    }
}
/* twine-user-script #7: "0070-InfoNode.js" */
// Node_

s.InfoNode = function(psgTitle, checkFunc) {
    /*
    `InfoNode` is a subclass of `Node`. It is a special kind of node
    which lies outside the narrative context of the game. Visiting an
    info node does not trigger an autosave. An info node has a default
    action with text, 'return to story', that takes the player back to
    the last non-info node by reloading the last autosave.

    @param {String} psgTitle - The title of the associated passage.
    @param {Function|Boolean} checkFunc (optional) - The function to
    call when checking if the `return to story` action should be
    displayed. Should return a boolean. If a boolean is provided, simply
    returns that boolean. Defaults to true.
    */
    s.Node.call(this, psgTitle);

    this._outOfChar = true;
    this.addAction('return to story', Save.autosave.load, checkFunc);

    return this;
};

s.InfoNode.prototype = Object.create(s.Node.prototype);

Object.defineProperty(s.InfoNode.prototype, 'constructor', {
    value: s.InfoNode,
    enumerable: false,
    writable: true
});

s.autosave.necessary.push(function() {
    // do not autosave when visiting an info node
    return (!(s.getNode(passage()) instanceof s.InfoNode));
});
/* twine-user-script #8: "0080-Parser_.js" */
// Node_

s.Parser = function() {
    /*
    A Parser object manages the conversion of the given passage text to
    the actual passage text used by SugarCube to display information.

    There is one instance (`st.parser`), built on State.variables, so
    its state can be stored in SugarCube's history. (This is needed,
    because the parser tracks dynamically generated text substitutions.)
    The class must therefore be made compatible with SugarCube by having
    `clone ()` and `toJSON()` methods, and no recursive objects or
    object sharing. To achieve this, we also require it to have a
    constructor with no arguments and to have all its properties be SC
    supported types.

    There are various methods for processing different kinds of markup.
    The method, `procMarkup()`, runs them all in the appropriate order.
    Through `Config.passages.onProcess`, we instruct SugarCube to apply
    `procMarkup()` to passage text whenever a passage is rendered.
    */
    this._textSubMap = new Map(); // Maps passage titles to arrays of
                                  // text subs. A text sub can be a
                                  // simple string or a functions
                                  // returning a string.
    return this;    
};

s.Parser.prototype._init = function(obj) {
    /* Needed for SugarCube compatibility. */
    Object.keys(obj).forEach(function (pn) {
        this[pn] = clone(obj[pn]);
    }, this);
    return this;
};

s.Parser.prototype.clone = function () {
    /* Needed for SugarCube compatibility. */
    return (new s.Parser())._init(this);
};

s.Parser.prototype.toJSON = function () {
    /* Needed for SugarCube compatibility. */
    var newPC = {};
    Object.keys(this).forEach(function (pn) {
        newPC[pn] = clone(this[pn]);
    }, this);
    return JSON.reviveWrapper(
        '(new s.Parser())._init($ReviveData$)', newPC
    );
};

s.Parser.prototype.getSubs = function(psgTitle) {
    return this._textSubMap.get(psgTitle);
}

s.Parser.prototype.setSubs = function(psgTitle, subArray) {
    /*
    Adds `psgTitle` key to `_textSubMap` with value `subArray`. Throws
    an error if `psgTitle` doesn't correspond to a node, length of
    `subArray` doesn't match the sub count of the node, or `subArray` is
    not an array of strings or functions. Returns the calling Parser
    object.
    */
    var node = s.getNode(psgTitle);
    if (node === undefined) {
        throw new Error(
            'Parser.setSubs():\n' +
            '"' + psgTitle + '" does not correspond to a node.'
        );
    }
    if (node.getSubCount() !== subArray.length) {
        throw new Error(
            'Parser.setSubs():\n' +
            'unexpected number of text substitutions'
        );
    }
    if (!subArray.every(function(element) {
        return (typeof(element) === 'string' ||
                typeof(element) === 'function');
    })) {
        throw new Error(
            'Parser.setSubs():\n' +
            'text substitutions must be strings or' +
            'functions that return strings'
        );
    }
    this._textSubMap.set(psgTitle, subArray);
    return this;
}

s.Parser.prototype.insertTextSubs = function(psgTitle, text) {
    /*
    Fetches the array of text substitutions corresponding to `psgTitle`,
    or `[]` if there is no such array, then replaces instances of
    `{<number>}` in the given text with corresponding elements from that
    array.

    Does nothing if the node associated with `psgTitle` has a sub count
    of 0. Throws an error if the sub count doesn't match the length of
    the substitution array, if any index is out of bounds, if any index
    is repeated, or if there are not enough indices. Returns the
    processed text.

    @param {String} psgTitle - The title of the passage being processed.
    This passage title must correspond to a node. Passing a title that
    does not correspond to a node could have unexpected behavior.
    @param {String} text - The text to process.
    */
    var subArray = (this.getSubs(psgTitle) || []);
    subArray = subArray.map(function(element) {
        if (typeof(element) === 'function') {
            return element();
        } else {
            return element;
        }
    });

    var psg = Story.get(psgTitle);
    var node = s.nodes.get(psg);
    var subCount = node.getSubCount();
    if (subCount === 0) {
        return text;
    }

    var psgId = psg.domId;
    var subsFound = new Set();
    var regex = /\{(\d+?)\}/;
    var processedText = text;
    var result, index;
    while (true) {
        result = regex.exec(processedText);
        if (result === null) {
            if (subsFound.size < subCount) {
                throw new Error(
                    'too few text substitutions in passage, "' +
                    psgTitle + '"'
                );
            }
            return processedText;
        }
        index = parseInt(result[1], 10);
        if (index >= subCount) {
            throw new Error(
                'text substitution index out of range in passage, "' +
                psgTitle + '"'
            );
        }
        if (subsFound.has(index)) {
            throw new Error(
                'duplicate text substitution index in passage, "' +
                passage.title + '"'
            );
        }
        subsFound.add(index);
        processedText = (
            processedText.slice(0, result.index) +
            subArray[index] +
            processedText.slice(result.index + result[0].length)
        );
    }
}

s.Parser.prototype.showDetails = function(description, id) {
    /*
    Inserts the given description into the element with the given id and
    clears all other elements with class `.description`. If the element
    with the given id already contains the given description, the
    function simply clears it.

    @param {String} description - the description to insert
    @param {String} id - the id of the containing element
    */
    var text = jQuery("#" + id).html();     // store the current content
                                            // for comparison

    jQuery(".description").empty()          // clear all elements

    jQuery("#" + id).wiki(description);     // insert the description

    if (text === jQuery("#" + id).html()) { // empty content if already
        jQuery("#" + id).empty();           // present
    }

    return;
}

s.Parser.prototype.procDetailMarkup = function(psgTitle, text) {
    /*
    Replaces instances of `{<link text>|id}` in text with links that
    reveal a description. The description is found in a corresponding
    instance of `{?id|description}` which is replaced by a div element
    into which the description appears. The html id of the div element
    is determined by both the id in the markup and the given `psgTitle`.
    The appearance of the description is controlled by the method
    `Parser.showDetails()`.

    The link text cannot begin with a `?` and cannot contain a `|`. The
    id must contain only letters, numbers, and `_`, and must begin with
    a letter.

    @param {String} psgTitle - The title of the passage being processed.
    @param {String} text - The text of the passage being processed.
    */
    var psg = Story.get(psgTitle);
    var psgId = psg.domId;

    var linkRegex = /\{(.+?)\|([a-zA-Z][0-9a-zA-Z_]*?)\}/;

    var processedText = text;

    var cut = [0,0,0,0];         // indices at which to cut the given
                                 // text

    var part = ['','','','','']; // substrings to concatenate in order
                                 // to build the new text

    var j;                       // temporary storage, used in building
                                 // `cut`

    var linkResult, linkText, linkId, elementId;
    var descRegex, descResult, descText, descLoc;
    while (true) {
        linkResult = linkRegex.exec(processedText);

        if (linkResult === null) {
            return processedText.replace(
                /\{\?([a-zA-Z][0-9a-zA-Z_]*?)\|(.+?)\}/g, ''
            );
        }
        
        linkId = linkResult[2];
        descRegex = new RegExp(
            '\\{\\?' + linkId + '\\|(.+?)\\}'
        );
        descResult = descRegex.exec(processedText);

        if (descResult === null) {
            throw new Error(
                'link markup without description markup in passage, "' +
                psgTitle + '"'
            );
        }

        linkText = linkResult[1];
        descText = descResult[1];
        elementId = psgId + '-examine-' + linkId;

        j = linkResult.index < descResult.index ? 0 : 2;
        cut[j] = linkResult.index;
        cut[j+1] = linkResult.index + linkResult[0].length;
        cut[2-j] = descResult.index;
        cut[3-j] = descResult.index + descResult[0].length;

        part[0] = processedText.slice(0, cut[0]);
        part[2] = processedText.slice(cut[1], cut[2]);
        part[4] = processedText.slice(cut[3])

        part[j+1] = (
            '<<link "' + linkText + '">>' +
                '<<run st.parser.showDetails(' + 
                    '"' + descText + '", "' + elementId + '"' +
                ')>>' +
            '<</link>>'
        );

        part[3-j] = (
            '<div id="' + elementId + '" class="description">' +
            '</div>'
        );

        processedText = part.join('');
    }
}

s.Parser.prototype.addContainers = function(psgTitle, text) {
    /*
    Wraps the given text in a `body` container; adds an `action`
    container for the action links; adds a `next` container in case the
    next node is to be loaded without a passage transition. The html id
    of the containers is determined by `psgTitle`.

    @param {String} psgTitle - The title of the passage being processed.
    This passage title must correspond to a node. Passing a title that
    does not correspond to a node could have unexpected behavior.
    @param {String} text - The text to process.
    */
    var psg = Story.get(psgTitle);
    return (
        '<div id="' + psg.domId + '-body">\n\n' +
            text + '\n\n' +
        '</div>\n\n' + 
        '<div id="' + psg.domId + '-actions"></div>\n\n' +
        '<div id="' + psg.domId + '-next"></div>'
    );

}

s.Parser.prototype.removeBreaks = function(text) {
    /*
    Removes line breaks from the given text.
    */
    var processedText = text.replace(/\r/g, '');
    processedText = processedText.replace(/^\n+|\n+$/g, '');
    processedText = processedText.replace(/\n+/g, ' ');
    return processedText;
}

s.Parser.prototype.procAllMarkup = function(psgTitle, text, time) {
    /*
    Processes the special node markup in the given passage (inserts text
    subs, processes the detail markup, adds the containers, and removes
    breaks. Does nothing if the given passage is not associated with a
    node. Returns the processed text.

    The optional `time` parameter is used to set the moment in SC's
    history from which to draw the values of variables. It allows for
    the use of variables in passage content. It should be a nonpositive
    integer. A value of 0 denotes the current moment. Defaults to zero.

    @param {String} psgTitle - The title of the passage being processed.
    @param {String} text - The text of the passage being processed.
    @param {Integer} time - (optional) A nonpositive integer that
    defaults to zero. Sets the moment in history to use when parsing.
    */
    var node = s.nodes.get(Story.get(psgTitle));
    if (node === undefined) {
        return text;
    }

    time = time || 0;
    if (time < 0) {
        s.loadVars(time);
    }

    var processedText = text;
    processedText = this.insertTextSubs(psgTitle, processedText);
    processedText = this.procDetailMarkup(psgTitle, processedText);
    processedText = this.addContainers(psgTitle, processedText);
    processedText = this.removeBreaks(processedText);

    if (time < 0) {
        s.loadVars(0);
    }

    return processedText;
}

st.parser = new s.Parser();
/* twine-user-script #9: "0090-DebugController_.js" */
// standard

s.DebugController = function() {
    /*
    The Debug Controller controls debug mode, a developer mode that can
    be used to activate certain capabilities and functionalities not
    present in ordinary gameplay. The state of debug mode is stored in
    the boolean property `debugOn` in SugarCube's `settings` namespace,
    which has `ss` as an alias.

    @property {Array} _cheatCode - An array of passage title strings.
    Loading the nodes associated to these passage titles in the given
    order toggles the state of debug mode.
    */
    this._cheatCode = [];
    return this;    
};

s.DebugController.prototype.getCheat = function() {
    return this._cheatCode;
}

s.DebugController.prototype.setCheat = function(psgTitles) {
    this._cheatCode = psgTitles;
    return this;
}

s.DebugController.prototype.checkUIBar = function() {
    /*
    By default, SugarCube's UI Bar is only visible during debug mode.
    This method ensures that the UI Bar is in the correct state.
    */
    if (ss.debugOn) {
      UIBar.unstow().show();
    } else {
      UIBar.hide().stow();
    }
    return this;
}

s.DebugController.prototype.onInit = function() {
    /*
    Runs on story initialization.
    */
    this.checkUIBar();
    return;
}

s.DebugController.prototype.onChange = function() {
    /*
    Runs when the debug state changes. Refreshes the current passage in
    order to display visible changes that might occur with the state
    change.
    */
    this.checkUIBar();
    Engine.show();
    return;
}

s.DebugController.prototype.toggle = function() {
    /*
    Toggles the debug state.
    */
    ss.debugOn = !ss.debugOn;
    Setting.save();
    this.onChange();
    return this;
}

s.debCon = new s.DebugController();

Setting.addToggle('debugOn', {
    /*
    Adds the `debugOn` boolean variable to `settings` and adds a toggle
    switch for it to the setting menu in the UI Bar. Binds the relevant
    `debCon` methods to the UI toggle switch.
    */
    label:      'debug mode',
    onInit:     s.debCon.onInit.bind(s.debCon),
    onChange:   s.debCon.onChange.bind(s.debCon)
});
/* twine-user-script #10: "0100-Page_.js" */
// InfoNode, Parser_, DebugController_

s.Page = function() {
    /*
    A `Page` object represents the content which is displayed on the
    screen. Traditionally in SugarCube, this is just a passage. But with
    the node system, multiple passages can be displayed at a time, in
    order. The first passage is the main one and the one which SugarCube
    regards as being displayed. The other passages are displayed inside
    the first passage.

    There is one instance (`st.page`), built on State.variables, so its
    state can be stored in SugarCube's history. (This allows SugarCube
    to rebuild the page upon a browser refresh or upon loading a save
    file.) The class must therefore be made compatible with SugarCube by
    having `clone()` and `toJSON()` methods, and no recursive objects or
    object sharing. To achieve this, we also require it to have a
    constructor with no arguments and to have all its properties be SC
    supported types.
    */
    this._embeddedPsgs = [];  // list of embedded passage titles; does
                              // not include the first (main) passage
    this._noBreakFlags = [];  // list of nobreak flags (true if passage
                              // was embedded without a scene break)
    this._continuous = false; // set true to have passages embed by
                              // default
    return this;    
};

s.Page.prototype._init = function(obj) {
    /* Needed for SugarCube compatibility. */
    Object.keys(obj).forEach(function (pn) {
        this[pn] = clone(obj[pn]);
    }, this);
    return this;
};

s.Page.prototype.clone = function () {
    /* Needed for SugarCube compatibility. */
    return (new s.Page())._init(this);
};

s.Page.prototype.toJSON = function () {
    /* Needed for SugarCube compatibility. */
    var newPC = {};
    Object.keys(this).forEach(function (pn) {
        newPC[pn] = clone(this[pn]);
    }, this);
    return JSON.reviveWrapper(
        '(new s.Page())._init($ReviveData$)', newPC
    );
};

s.Page.prototype.length = function() {
    return this._embeddedPsgs.length;
}

s.Page.prototype.getPsg = function(index) {
    return this._embeddedPsgs[index];
}

s.Page.prototype.getFlag = function(index) {
    return this._noBreakFlags[index];
}

s.Page.prototype.isContinuous = function() {
    return this._continuous;
}

s.Page.prototype.setContinuous = function(val) {
    this._continuous = val;
    return this;
}

s.Page.prototype.innerPsg = function() {
    /*
    Returns the innermost passage on the page as a SC Passage object.
    */
    var psg;
    if (this._embeddedPsgs.length === 0) {
        psg = Story.get(passage());
    } else {
        var title = this._embeddedPsgs[this._embeddedPsgs.length - 1];
        psg = Story.get(title);
    }
    return psg;
}

s.Page.prototype.insertPsgText = function(psg, shellPsg, time, nobreak) {
    /*
    Inserts the given passage into the given shell passage, preceded by
    a scene break ("****"). The scene break is omitted is `nobreak` is
    true.

    The optional `time` parameter is used to set the moment in SC's
    history from which to draw the values of variables. It allows for
    the use of variables in passage content. It should be a nonpositive
    integer. A value of 0 denotes the current moment. Defaults to zero.

    @param {<<SC Passage object>>} psg - The passage to embed.
    @param {<<SC Passage object>>} shellPsg - The passage into which to
    embed.
    @param {Integer} time - (optional) A nonpositive integer that
    defaults to zero. Sets the moment in history to use when parsing.
    @param {Boolean} nobreak - (optional) Defaults to false. Set to true
    to omit the scene break marker.
    */
    time = time || 0;
    if (time < 0) {
        s.loadVars(time);
    }

    var sceneBreak = nobreak ? '' : '<p style="text-align:center">****</p>';
    $('#' + shellPsg.domId + '-next').wiki(
        sceneBreak +
        st.parser.procAllMarkup(psg.title, psg.text)
    );

    if (time < 0) {
        s.loadVars(0);
    }

    return this;
}

s.Page.prototype.insertActions = function(psg) {
    /*
    For each action in the node corresponding to the given SC passage
    object, this function checks if the action should be displayed. If
    it passes the check, it adds a link for the corresponding action.
    Does nothing if the incoming passage does not correspond to a node.
    */
    var node = s.nodes.get(psg);
    if (node === undefined) {
        return;
    }

    var psgTitle = psg.title;
    var psgId = psg.domId;
    var action;
    for (var i = 0; i < node.length(); i++) {
        action = node.get(i);
        if (action.check()) {
            $('#' + psgId + '-actions').wiki(
                '<p style="text-align:' + action.getAlign() + '">' +
                    '<<link "' + action.getText() + '">>'+
                        '<<run s.nodes.get(Story.get("' + psgTitle + '"))' +
                        '.get(' + i + ').choose().carryOut()>>' +
                    '<</link>>' +
                '</p>'
            );
        }
    }
    return this;
}

s.Page.prototype.refreshActions = function() {
    /*
    Deletes the actions on the page and reinserts them. Can be used
    after dynamically changing variables on which action check functions
    depend.
    */
    var latestPsg = this.innerPsg();
    $('#' + latestPsg.domId + '-actions').empty();
    this.insertActions(latestPsg);
    return this;
}

s.Page.prototype.scrollToLast = function() {
    /*
    Scrolls to put the innermost passage at the top.
    */
    $('html, body').animate({
        scrollTop: $('#' + this.innerPsg().domId + '-body').position().top
    }, 0);
    return this;
}

s.Page.prototype.embedPsg = function(node, time, nobreak) {
    /*
    Removes the current actions from the page, inserts the given node
    and its actions into the bottom of the page, scrolls to put the new
    content at the top, appends the page's list of embedded passages,
    and adds a new moment to SC's history. The embedded passage is
    preceded by a scene break ("****") unless `nobreak` is true.

    The time parameter is a nonpositive integer that defaults to zero
    and sets the moment in history to use when parsing. See
    `Page.insertPsgText` for details.
    */
    if (s.getNode(passage()) == undefined) {
        throw new Error(
            'Page.embedPsg():\n' +
            'shell passage not associated with a node'
        );
    }

    var nodePsg = node.getPassage();
    if (nodePsg.title === passage() ||
        this._embeddedPsgs.indexOf(nodePsg.title) >= 0) {
        throw new Error(
            'Page.embedPsg():\n' +
            'cannot embed a passage in itself'
        );
    }

    var latestPsg = this.innerPsg();
    $('#' + latestPsg.domId + '-actions').empty();
    this.insertPsgText(nodePsg, latestPsg, time, nobreak);
    this.insertActions(nodePsg);
    this._embeddedPsgs.push(nodePsg.title);
    this._noBreakFlags.push(nobreak);
    this.scrollToLast();
    State.create(State.passage);
    Save.autosave.save();
    return this;
}

s.Page.prototype.load = function(node, embed, nobreak) {
    /*
    Checks the debug controller's cheat code and toggles debug mode if
    necessary.

    Runs the given node's `onLoad` function, then renders the node's
    passage. If the optional parameter `embed` is true, then rather than
    rendering the passage, the passage's contents are appended to the
    end of the last embedded passage, the page is scrolled to put the
    new passage content at the top, and a new moment is added to SC's
    history. The appended content is preceded by a scene break ("****"),
    unless the optional `nobreak` parameter is true.

    If node is an info node, `embed` and `nobreak` have no effect.
    Instead, the associated passage is loaded without adding to the SC
    history.
    */
    var code = s.debCon.getCheat();
    var L = code.length;
    if (
        code[L - 1] === node.getPassage().title &&
        State.length >= L &&
        code.slice(0, L - 1).every(function(psgTitle, i) {
            return code[i] === State.peek(L - 2 - i).title;
        })
    ) {
        s.debCon.toggle();
    }

    if (embed === undefined) {
        embed = this._continuous;
    }
    if (passage() === 'Start' || node instanceof s.InfoNode) {
        embed = false;
    }

    node.onLoad();
    var nodePsg = node.getPassage();
    if (embed) {
        this.embedPsg(node, 0, nobreak);
        return this;
    } else {
        this._embeddedPsgs = [];
        this._noBreakFlags = [];
        Engine.play(nodePsg.title);
        return this;
    }
}

st.page = new s.Page();

s.preProcText = []; // an array of size-2 arrays; preProcText[i][0] is
                    // the title of a passage, preProcText[i][1] is a
                    // function to apply to that passage's text before
                    // SC's text processing.

Config.passages.onProcess = function(p) {
    /*
    Prepends passage text with an HTML linebreak if the passage is the
    header passage or if the passage is tagged with `no-header`. Does
    nothing further if the current passage is not associated with a
    node.

    Rewinds variables to a previous moment to account for embedded
    passages. Variables will be restored on `:passagedisplay`. Then
    processes the node markup.
    */
    var text = p.text;
    for (var i = 0; i < s.preProcText.length; i++) {
        if (p.title === s.preProcText[i][0]) {
            text = s.preProcText[i][1](text);
        }
    }

    if (s.getNode(p.title) === undefined) {
        return text;
    }

    s.loadVars(-st.page.length());
    var processedText = st.parser.procAllMarkup(p.title, text);
    return processedText;
};

$(window).bind('beforeunload pagehide', function(){
    /*
    Restart upon browser refresh. Otherwise, upon browser refresh,
    `Page.scrollToLast()` will not fire. (It fires too early, before the
    reloaded page is ready, and we cannot bind to any event that
    triggers after the page is fully reloaded.) This ad hoc solution
    requires that the 'Start' passage offer a way to reload the
    autosave.
    */
    Engine.restart();
});

$(document).one(':enginerestart', function (ev) {
    /*
    To perform a 'hard restart' (i.e. to delete the autosave before
    restarting), set 'hardRestart' to true in the metadata before
    restarting.
    */
    if (recall('hardRestart', false)) {
        Save.autosave.delete();
        forget('hardRestart');
    }
});

$('#menu-item-restart').remove() // remove default Restart button

s.restart = function() {
    /*
    In general, this custom restart function is preferred over
    `Engine.restart()` and is what should be triggered by any 'restart'
    menu items. In particular, the default 'Restart' button in the UI
    bar should be removed.

    In general, this function performs a hard restart. If it was called
    from the 'Start' passage, sets 'autoBegin' to true in the metadata.
    The start passage can use this metadata to immediately move to the
    next passage in the story rather than simply refresh itself.
    */
    memorize('hardRestart', true);
    if (passage() === 'Start') {
        memorize('autoStart', true);
    }
    Engine.restart();
}

s.onPsgDisplay = function(ev) {
    /*
    Triggered by the `:passagedisplay` event. Rebuilds the current page.
    Does nothing if the current passage is not associated with a node.
    */
    if (s.getNode(ev.passage.title) === undefined) {
        return;
    }

    s.loadVars(0); // resets variables to current time

    var currentPsg = ev.passage;
    var nextPsg, time;
    for (var i = 0; i < st.page.length(); i++) {
        /*
        Re-inserts embedded passage text one at a time.
        */
        nextPsg = Story.get(st.page.getPsg(i));
        time = i - (st.page.length() - 1)
        st.page.insertPsgText(
            nextPsg, currentPsg, time, st.page.getFlag(i)
        );
        currentPsg = nextPsg;
    }

    st.page.insertActions(st.page.innerPsg());
    st.page.scrollToLast();
    return;
}

$(document).on(':passagedisplay', s.onPsgDisplay);
/* twine-user-script #11: "0110-Version.js" */
// standard

s.Version = function(major, minor, patch) {
    /*
    Keeps track of a three-part version number and returns it in
    multiple useful formats. There is one predefined instance,
    `version`. (See below.)

    @property {Integer} _major - Should be a nonnegative integer less
    than 1000. Defaults to 0.
    @property {Integer} _minor - Should be a nonnegative integer less
    than 1000. Defaults to 0.
    @property {Integer} _patch - Should be a nonnegative integer less
    than 1000. Defaults to 1, if others are zero; otherwise, defaults to
    0.
    */
    major = major || 0;
    minor = minor || 0;
    patch = patch || ((major === 0 && minor === 0) ? 1 : 0);
    this.set(major, minor, patch);
    return this;
}

s.Version.prototype.asArray = function() {
    /*
    Returns the version number as an array of three integers.
    */
    return [this._major, this._minor, this._patch];
}

s.Version.prototype._arrToStr = function(arr) {
    /*
    Converts a version number formatted as an array to a string. Returns
    the string. If the patch part is 0, it is not included in the
    string.
    */
    var string = arr[0].toString() + '.' + arr[1].toString();
    if (arr[2] > 0) {
        string += '.' + arr[2].toString();
    }
    return string;
}

s.Version.prototype._strToArr = function(string) {
    /*
    Converts a version number formatted as a string to an array. Returns
    the array.
    */
    var arr = string.split('.').map(function(part) {
        return parseInt(part, 10);
    });
    if (arr.length === 2) {
        arr.push(0);
    }
    return arr;
}

s.Version.prototype._arrToInt = function(arr) {
    /*
    Converts a version number formatted as an array to an integer.
    Returns the integer.
    */
    return 1000000 * arr[0] + 1000 * arr[1] + arr[2];
}

s.Version.prototype._intToArr = function(num) {
    /*
    Converts a version number formatted as an integer to an array.
    Returns the array.
    */
    var arr = [0,0,0];
    arr[2] = num % 1000;
    num = (num - arr[2])/1000;
    arr[1] = num % 1000;
    arr[0] = (num - arr[1])/1000;
    return arr;
}

s.Version.prototype.intToStr = function(num) {
    /*
    Converts a version number formatted as an integer to an object with
    `major`, `minor`, and `parts` properties. Returns the object.
    */
    return this._arrToStr(this._intToArr(num));
}

s.Version.prototype.asString = function() {
    /*
    Returns the version number as a string, such as `'2.113.86'`. If the
    `_patch` parameter is 0, it is not included in the string.
    */
    return this._arrToStr(this.asArray());
}

s.Version.prototype.asInteger = function() {
    /*
    Returns the version number as a potentially nine-digit integer. For
    example, 32.3.86 corresponds to 32003086.
    */
    return this._arrToInt(this.asArray());
}

s.Version.prototype.set = function(major, minor, patch) {
    /*
    Sets the corresponding properties. Throws an error if any
    parameter is not a nonnegative integer less than 1000, or if all
    parameters are 0. Returns the `Version` object.

    @param {Integer} major - A nonnegative integer less than 1000.
    @param {Integer} minor - A nonnegative integer less than 1000.
    @param {Integer} patch - A nonnegative integer less than 1000.
    Cannot be zero if both major and minor are zero.

    @return {Version}
    */
    for (var i = 0; i < 3; i++) {
        if (arguments[i] !== parseInt(arguments[i], 10) ||
            arguments[i] < 0 ||
            arguments[i] > 999) {
            throw new Error(
                'Version._init():\n' +
                'numbers must be nonnegative integers less than 1000'
            );
        }
    }
    if (major + minor + patch === 0) {
        throw new Error(
            'Version._init():\n' +
            'parts cannot all be 0'
        );
    }
    this._major = major;
    this._minor = minor;
    this._patch = patch;
    Config.saves.version = this.asInteger();
    return this;
}

s.version = new s.Version();
/* twine-user-script #12: "0120-SavesManager_.js" */
// Version

s.SavesManager = function(block) {
    /*
    A `SavesManager` object manages the autosave, the bookmark(s), and
    any checkpoints that might have been created.

    @property {Boolean} block - If true, will block the loading of saves
    whose version does not match the current version. Defaults to false.
    */
    if (block == null) {
        this._block = false;
    } else {
        this._block = block;
    }
    return this;    
};

s.SavesManager.prototype.setBlock = function(bool) {
    this._block = bool;
    return this;
}

s.SavesManager.prototype.get = function(num) {
    /*
    Returns the save whose label in the saves dialog box matched `num`.
    If `num` is 0, returns the autosave.
    */
    if (num === 0) {
        return Save.autosave.get();
    } else {
        return Save.slots.get(num - 1);
    }
}

s.SavesManager.prototype.load = function(num) {
    /*
    Loads the save whose label in the saves dialog box matched `num`. If
    `num` is 0, loads the autosave.
    */
    if (this._block) {
        var verInt = this.get(num).version;
        if (verInt !== s.version.asInteger()) {
            var verStr = s.version.intToStr(verInt);
            alert(
                'save file is from version ' + verStr + ';\n' +
                'current version is ' + s.version.asString() + ';\n' + 
                'unable to load.'
            );
            return;
        }
    }
    if (num === 0) {
        Save.autosave.load();
    } else {
        Save.slots.load(num - 1);
    }
    return this;
}

s.savesMgr = new s.SavesManager();
/* twine-user-script #13: "0130-Menu_.js" */
// SavesManager_, ActionList, Page_

/*
The `Menu` object will contain functionality to restart the story. But
because of a technical issue, we need to redefine how SC restarts the
story. Hence, we do both these things before defining the `Menu` class.

The normal (and preferred) behavior in SC is for a browser refresh to
leave the story in the same state, essentially reloading the current
moment. But with embedded passages, the current displayed text could be
quite long and it's important that at the end of reloading, the page is
scrolled to the bottom.

In it's current implementation, the browser refresh takes too long, so
the scroll function is executed too early and has no effect. There
doesn't seem to be any way to time it reliably, so the workaround is to
have the story restart upon browser refresh, and have the `Start`
passage offer a way to resume the story by loading the autosave.

Ideally, the behavior of the 'Restart' button in the UI bar should be
modified to accommodate this change. But its behavior is fixed, so we
instead opt to remove it. A custom restart button should be added to
preserve the desired functionality.
*/

s.Menu = function() {
    /*
    A `Menu` object is an `ActionList` with built-in `begin`, `resume`,
    and `restart` actions. The `restart` method is kept at the end of
    the list. The `begin` method is customizable. These actions are
    automatically inserted into various areas of the story (such as the
    header under normal circumstance, the UI bar in debug mode, and the
    bottom of the `Start` passage.)
    */
    s.ActionList.call(this, true);
    this.addAction(
        'restart',
        function() {
            if (ss.debugOn || confirm('Really restart?')) {
                s.restart();
            }
        },
        function() {
            return (
                passage() !== 'Start' ||
                Save.autosave.has()
            );
        }
    );
    this.onBegin();
    this.addAction(
        'resume',
        function() {
            s.savesMgr.load(0);
        },
        function() {
            return (
                passage() === 'Start' &&
                Save.autosave.has()
            );
        }
    );
    return this;
};

s.Menu.prototype = Object.create(s.ActionList.prototype);

Object.defineProperty(s.Menu.prototype, 'constructor', {
    value: s.Menu,
    enumerable: false,
    writable: true
});

s.Menu.prototype.addAction = function(text, carryOutFunc, checkFunc, index) {
    /*
    @override

    This method is for adding a simple action with one outcome to the
    list. It creates an outcome that executes `carryOutFunc`, adds it as
    the single outcome to a new action with link text `text` and check
    function `checkFunc`. The default behavior of `checkFunc` is to
    allow the action if not on the start screen.
    */
    if (checkFunc === undefined) {
        checkFunc = function() {
            return (passage() !== `Start`);
        }
    }
    return s.ActionList.prototype.addAction.call(
        this, text, carryOutFunc, checkFunc, index
    );
}

s.Menu.prototype.onBegin = function(func) {
    /*
    Sets the `begin` action to carry out the given function.
    */
    if (this.get(0).getText() === 'begin') {
        this.delete(0);
    }
    this.addAction('begin', func, function() {
        return (
            passage() === 'Start' &&
            !Save.autosave.has()
        );
    }, 0);
    return this;
}

s.menu = new s.Menu();

s.autoStart = function() {
    /*
    Automatically carry out the 'begin' or 'resume' actions, whichever
    is available.
    */
    var begin = s.menu.getAction('begin');
    if (begin.check()) {
        begin.choose().carryOut();
        return;
    }
    if (ss.debugOn) {
        var resume = s.menu.getAction('resume');
        if (resume.check()) {
            resume.choose().carryOut();
            return;
        }
    }
}

s.menuMarkup = function() {
    /*
    Returns the text of the SC markup that renders the links in the
    displayed menu bar.
    */
    var text = '';
    var action;
    for (var i = 0; i < s.menu.length(); i++) {
        action = s.menu.get(i);
        if (!action.check()) {
            continue;
        }
        if (text !== '') {
            text += ' / ';
        }
        text += (
            '<<link "' + action.getText() + '">>' +
                '<<run s.menu.get(' + i + ').choose().carryOut()>>' +
            '<</link>>'
        );
    }
    return text;
}

s.preProcText.push(['StoryMenu', function(text) {
    /*
    Adds the menu to the UI bar if it is visible and the current passage
    allows the menu.
    */
    if (!UIBar.isHidden() && !tags().includes('no-menu')) {
        return s.menuMarkup();
    } else {
        return '';
    }
}]);

s.preProcText.push(['PassageHeader', function(text) {
    /*
    Adds the menu to the header with the sticky class if the current passage
    allows it, unless currently at the Start passage. Otherwise, adds a
    line break to compensate for the reduced upper margin (needed to
    have the sticky class work as intended).
    */
    return (
        '<<if !tags().includes("no-menu") && passage() !== "Start">>' +
            '<div class="sticky"><br>' +
                s.menuMarkup() + '<br><hr>' +
            '</div>' +
        '<<else>>' +
            '<br>' +
        '<</if>>'
    );
}]);

s.preProcText.push(['Start', function(text) {
    /*
    Use the autoStart metadata from the s.restart() function to skip the
    title page.
    */
    return (
        '<<timed 0s>>' +
            '<<if ss.debugOn || recall("autoStart", false)>>' +
                '<<run forget("autoStart")>>' +
                '<<run s.autoStart()>>' +
            '<</if>>' +
        '<</timed>>' +
        text
    );
}])

s.preProcText.push(['Start', function(text) {
    /*
    Adds the menu to the bottom of the Start passage.
    */
    return (
        text + '<br>' +
        '<div style="text-align:center">' +
            s.menuMarkup() +
        '</div>'
    );
}]);
/* twine-user-script #14: "8000-functions.js" */
// Page_

s.addLink = function(startPsgTitle, text, endPsgTitle,
                      func, checkFunc, embed, nobreak) {
    /*
    Creates a new Outcome that runs `func`, then loads the node
    associated with `endPsgTitle`. Then adds that Outcome to a new
    Action with the given `text` as its link text. Then adds that Action
    to the associated with `startPsgTitle`. The target node is loaded
    with the optional `embed` and `nobreak` parameters. The action is
    given `checkFunc` as its check function.

    If there are no nodes associated with the given passage titles, they
    will be created.
    */
    if (endPsgTitle == null && func == null) {
        throw new Error(
            'addLink():\n' +
            'link must load a node or execute a function'
        );
    }

    var startNode = s.nodes.get(Story.get(startPsgTitle));
    if (startNode === undefined) {
        startNode = new s.Node(startPsgTitle);
    }

    var targetNode;
    if (endPsgTitle != null) {
        targetNode = s.nodes.get(Story.get(endPsgTitle));
        if (targetNode === undefined) {
            targetNode = new s.Node(endPsgTitle);
        }
    }

    var carryOutFunc;
    if (endPsgTitle == null) {
        carryOutFunc = func;
    } else if (func == null) {
        carryOutFunc = function() {
            st.page.load(targetNode, embed, nobreak);
        }
    } else {
        carryOutFunc = function() {
            func();
            st.page.load(targetNode, embed, nobreak);
        }
    }

    startNode.addAction(text, carryOutFunc, checkFunc);
    return;
}

s.loadNode = function(psgTitle, embed) {
    st.page.load(s.getNode(psgTitle), embed);
    return;
}

s.loadInfoNode = function(psgTitle, checkFunc) {
    /*
    If `psgTitle` is associated with an info node, loads the info node.
    If `psgTitle` is associated with a non-info node, throws an error.
    If `psgTitle` is not associated with a node, creates a new info
    node with the given parameters and loads it.
    */
    var node = s.getNode(psgTitle);
    if (node === undefined) {
        var newNode = new s.InfoNode(psgTitle, checkFunc);
        st.page.load(newNode);
        return;
    }
    if (node instanceof s.InfoNode) {
        st.page.load(node);
        return;
    }
    throw new Error(
        'loadInfoNode():\n' +
        '"' + psgTitle + '" is not an info node'
    );
}

s.setSubCount = function(psgTitle, num) {
    /*
    Sets the sub count of the node associated with `psgTitle` to `num`.
    If no such node exists, creates one. Returns the associated node.
    */
    var node = s.getNode(psgTitle);
    if (node === undefined) {
        node = new s.Node(psgTitle, num);
        return node;
    } else {
        return node.setSubCount(num);
    }
}

s.copyActions = function(fromPsgTitle, toPsgTitle) {
    /*
    For each action in the node associated with `fromPsgTitle`, pushes
    that action to the node associated with `toPsgTitle`.
    */
    var fromNode = s.getNode(fromPsgTitle);
    var toNode = s.getNode(toPsgTitle);
    for (var i = 0; i < fromNode.length(); i++) {
        toNode.push(fromNode.get(i));
    }
    return;
}
/* twine-user-script #15: "9000-main.js" */
s.version.set(0,4,6);
s.savesMgr.setBlock(true); // block loading of saves from old versions
st.page.setContinuous(true); // make embedding passages the default

// build menu
s.menu.onBegin(function() {
    s.loadNode('intro');
});
s.menu.addAction('info', function() {
    s.loadInfoNode('help');
});
s.menu.addAction('bio', function() {
    s.loadInfoNode('bio');
});

// set cheat code for debug mode
s.debCon.setCheat([
    'help', 'help', 'help', 'bio', 'help', 'bio', 'help', 'help', 'bio'
]);

// make initial links
s.addLink('intro', 'continue', 'RNG warning');
s.addLink(
    'RNG warning', 'got it', 'who you are', null, null, false // don't embed
);
s.addLink('who you are', 'take a look around', 'bedroom');

// bedroom actions

    // take the knife
    s.addLink('bedroom', 'take the knife', 'Taking knife', function() {
        // carry out
        v.containedIn.delete('knife');
        v.inventory.add('knife');
    }, function() {
        // check
        return (v.containedIn.get('knife') === 'bedroom');
    }, true, true); // embed with scene break

    // search the body
    s.setSubCount('Cops bust in', 2);
    s.addLink('bedroom', 'search the body', 'Cops bust in', function() {
        // carry out
        v.body.searched = true;
        v.pounding = false;
        st.parser.setSubs('Cops bust in', [
            '',

            'As you bend down to take a closer look at the body, ' +
            'the bedroom door bursts open. '
        ]);
    }, function() {
        // check
        return !v.body.searched;
    });

    s.addLink('bedroom', 'mark body as searched', null, function() {
        v.body.searched = true;
        State.create(State.passage);
        st.page.refreshActions();
    }, function() {
        return !v.body.searched;
    });

    s.addLink('bedroom', 'mark body as not searched', null, function() {
        v.body.searched = false;
        State.create(State.passage);
        st.page.refreshActions();
    }, function() {
        return v.body.searched;
    });

// Taking knife actions
s.copyActions('bedroom', 'Taking knife');

// Cops bust in actions
s.addLink('Cops bust in', 'continue', 'Next');
/* twine-user-script #16: "Story JavaScript" */


:: StorySubtitle
Story Subtitle


:: StoryAuthor
Story Author


:: StoryDisplayTitle
Story Display Title


:: StoryBanner
Story Banner


:: StoryCaption
Story Caption


:: StoryMenu
/* This passage needs to be here and should be empty */


:: StoryInit
<<set $pounding = true>>
<<set $crowbar = false>>
<<set $knowledge = new Set()>>
<<set $containedIn = new Map()>>
<<run $containedIn.set("knife", "bedroom")>>
<<set $body = {
    searched: false
}>>
<<set $detective = {
    discovered: false
}>>
<<set $inventory = new Set()>>


:: PassageHeader
/* This passage needs to be here and should be empty */


:: help
<p>The story you are reading is a work of interactive fiction. In interactive fiction you play the main character of a story. Your actions drive the story forward.</p>

<p>In this story, you control the character by tapping (or clicking) on links. Tap a noun to examine that object in closer detail. Tap a command to follow that action. Tapping a noun will usually not advance the story. Tapping a command, though, is often irreversible.</p>

<p><b class="headings">Random outcomes.</b> Some actions may have a random outcome which could be good or bad. Your chances of getting a good outcome are related to your character's traits. Click on "view Character Sheet" in the footer to better understand these traits. The Character Sheet also shows what you are carrying, what you have learned, and any injuries you may have suffered.</p>

<p><b class="headings">Saving.</b> The story automatically saves your progress, so if you exit and reload later, you will be able to resume right where you left off. You can also manually save your progress in a bookmark that can be reloaded later. But think carefully about this. You only get one bookmark! (Warning: using private browsing or disabling or clearing your cookies will interfere with the story's saving feature.)</p>


:: bio
<p>This screen holds information about your character.</p>


:: Start
/* Cannot be used as a node; should not have branching choices. */
<div style='text-align:center'>
    <h1><<= Story.title>></h1>
    by<br>
    <<= Story.get('StoryAuthor').text>><br>
    version <<= s.version.asString()>><br>
    <br>
    <br>
    <br>
</div>


:: intro [no-menu]
<p>It started with one shot of whiskey. Of course, most nights started with one shot of whiskey. Then one became two and two became more. Before long, you were making a fool of yourself. At least you assume you were. You can't remember.</p>

<p>That was last night. This morning, you wake up alone on a strange bed in a house you've never seen before. From the trash and bottles lying around, this had to be the scene of some after-party. But where is everyone? And what is that smell? It's then you realize your clothes are covered in blood.</p>

<p>When you get out of the bed, you see it. The body. A man lying on his back, dead, with a knife sticking out of his chest. Before you can do or think anything, someone starts pounding on the front door. Is it the police? Is it the murderer? Are //you// the murderer?</p>


:: RNG warning [no-menu]
<p>In this story, your choices can have random consequences. The chances of the various outcomes are affected by your character's traits. You can read about those traits on the Character Sheet. The Character Sheet also shows what you are carrying, what you have learned, and any injuries you may have suffered.</p>


:: who you are
<p>Scott Allen Brady. Scotty, to your friends. That's your name. You have to remind yourself, just to make sure you haven't forgotten //everything//. The last thing you remember is leaving work. You'd finished packing the motherboards into their shipping crates. Then you clocked out and left the plant. You were still wearing your Hewlett-Packard shirt when you got in your truck. You met some friends at the bar. Then...</p>

<p>Nothing. You can't remember. Now here you are, in some surreal nightmare, looking at a dead guy. The pounding on the door makes it hard to concentrate.</p>


:: bedroom
<p>You are in what has to be the master bedroom. You reek of alcohol, your mouth is dry and tastes like vomit, and your head is throbbing. There's blood on your clothes, in your hair, and on your face and hands. You've had better days.</p>

<p>You're wearing a white T-shirt with the Seattle Seahawks logo on the front. But you can hardly see the logo under all the blood. Your jeans are also caked with dried blood.</p>

<p>On your left, the {bedroom door|A} is closed. <<if $pounding>>You can hear the pounding on the front door coming from that direction. <<elseif $crowbar>>Outside the bedroom, <<if $knowledge.has("policeAtDoor")>>the police are<<else>>someone is<</if>> breaking into the house with a crowbar. <</if>>To your right, the {door|B} to the adjoining bathroom is ajar. On the floor is a {dead man|C}, lying on his back in a pool of blood. <<if $containedIn.get("knife") == "bedroom">>What looks like a heavy-duty {chef's knife|D} is sticking out of his chest.<</if>></p>

{?A|<p>The bedroom door is white, like the walls of the room. Blood is spattered on the left side near the door handle.</p>}

{?B|<p>The bathroom door is made of cheap plywood and won't even close all the way.</p>}

{?C|<p>You've never seen the dead man before, as far as you can remember. He must be in his mid-thirties.</p>}

{?D|<p>The murder weapon looks like the kind of knife they have hanging on the wall in a restaurant kitchen--the kind they use to cut meat or chop big vegetables. It has a wide blade and is about a foot long.</p>}


:: Cops bust in
<p>{0}</p>

<p>{1}Three men rush in. "Get down on the ground!" one shouts. <<if $inventory.has("knife")>>"He's got a knife!" yells another.<</if>> They all have their guns trained on you. The bald man in the center looks like a police {detective|A}. The other two are uniformed cops.</p>

{?A|The detective doesn't move. He doesn't blink. He just stands there scowling, waiting for you to make a move.}


:: Taking knife
<p>You take the knife and carefully slide it under your belt. You may need this for later.</p>


:: Next
To be continued.


